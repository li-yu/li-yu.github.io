{"posts":[{"title":"Project Leader: 以终为始，自驱成长","content":" 项目的主心骨，不只是项目的执行者，更是团队节奏的掌舵人。 有次和团队小伙伴聊绩效时，问及团队里最认可谁，他说 XX（角色是 Project Leader，以下简称 PL），我问他原因，他列举了很多事例，我又问他，为啥 XX 做得好呢？他说可能是因为把 XX 架在了 PL 的位置，所以他干的活和大家不一样了，得到了更多的曝光机会，于是更加卖命，自然干得很好。 不可否认，确实可能有这方面原因，但背后的低层逻辑真的是这样吗？看似又回到了最初的问题：“到底先有鸡还是先有蛋？”。 PL 的核心特质很难“培养”，更像是“识别” 某些特质是天生的，比如责任心、上进心、自驱力，还有抗压能力和对目标感的执着。 这些特质，不是安排个培训、布置个任务他就能突然具备的，更多是骨子里的东西。 所以，我更倾向于把“培养 PL”理解成：识别 + 赋能： 通过观察工作状态，比如谁在项目中主动补位、愿意操心整体节奏、愿意为结果负责，而不是只做份内的任务。 不是告诉他具体怎么做，而是提供一些项目或者活动让他尝试，看他有没有全局意识和成长能力。 真正具备 PL 潜质的人，其实内驱很强，反而是需要帮他构建框架感、决策感，而不是从零培养他“怎么当一个 project leader”。 简单来说：识别潜质、给予舞台、拉齐认知 实践经验 去年一个新加入的小伙伴，本身技术能力和沟通能力都不错，进来做了一个中等体量的功能移植开发，整体交付也算顺利，没过多操心，但是到了后期我发现，面对一些枯燥的 bug 时，他的解决效率是相当慢，了解完背后的真实原因，发现他在面对这些琐碎、重复且缺乏成就感的问题时，容易陷入一种“过度分析”或“等待完美解法”的状态。一开始我以为是当时状态不佳，但深入聊过之后才意识到，他其实是比较在意工作带来的价值感和挑战性，一旦任务本身无法激发兴趣，就容易陷入“拖延性思考”，甚至烦躁状态，而不是快速行动。 后面我尝试做了两件事： 查看了他入职时的大五人格测评，分析了强弱项，之后调整了其工作安排，让他带领一个三人小队进行 App 架构优化和新功能预研 明确阶段性目标和优先级，让他明白“先解决最小闭环”，而不是追求一次性完美。 目前看，效果还是不错的。 🎯 大五人格测评理论基础扎实 全球最被广泛验证的人格模型之一 多语言、多文化中重复验证 被用于人才评估、职业匹配、领导力发展等领域 对于 PL 角色识别的时候，可以作为参考，再结合实际情况做决策。 一些困惑 1. “亲力亲为”是责任感，还是不信任？ 包括自己在内，一些 PL 在项目过程中经常会陷入亲力亲为的状态： 自己盯需求、自己拆任务、自己写核心代码、自己扛上线、甚至自己亲自拉通…… 好像只有自己动手，才“保险”、才“不掉链子”。 2. PL 的绩效，到底该怎么打才公平？ PL 的工作不像开发那样好量化，他们更多是协调、把控和责任。那打分的时候，到底是： 和别的 PL 横向比？ 还是和他自己负责的项目结果比？ 还是我的主观感受？ 这到底谁更“好”？分数上怎么体现？其实挺难量化的。 总之 PL 不只是一个角色，更是一种成长方式。 在目标与混乱之间找平衡，在责任与信任之间做选择，既要扛得住压力，也要带得动团队。 与其说是培养别人，不如说是我们每个人在不断成为更好的自己。 ","link":"https://liyuyu.cn/post/project-leader-yi-zhong-wei-shi-zi-qu-cheng-chang/"},{"title":"App Widgets 设计与开发","content":"App 小部件（widgets）可以把重要的内容直接在桌面中呈现给用户，以提升用户在桌面获取信息与直达服务的效率。 不过因平台的差异性，Android 和 iOS 对于小部件的规范和实现也不一样，同时国内基于 Android 系统定制的各厂商也对小部件有着各自的开发规范。 Android 设计 布局（Layouts）：对于文字、图片、按钮、列表、网格布局的指导规范 大小（Sizing）：官方推荐的尺寸作为起点，并在不同尺寸上测试布局，以确保最佳的可读性和用户体验 样式（Style）：定义颜色和排版的关键概念和技术，主要涉及颜色和黑暗主题等等 发现和推广（Discovery &amp; promotion）：用户可以通过小部件选择器发现和添加您的小部件 开发 除了传统的 XML 体系，Android 官方 Jetpack Glance 也提供了一种使用 Compose 语法构建 widget 的新式方法， 但受 AppWidgets 和 RemoteViews 的限制，Glance 使用的 Compose 与 Jetpack Compose 本质上是不一样的。 布局类型 Android 小部件支持的布局形式和控件类型是有限的： 对应的其实就是传统布局上的 RelativeLayout 和 LinearLayout 此外，可滚动的列表，Glance 会将 LazyColumn 转换为实际的 ListView 控件类型 仅支持 Text、Image 等基础控件，Android 12 及以后支持CheckBox、Switch 和 RadioButton等复合控件，集合视图支持 ListView、GridView、StackView和AdapterViewFlipper Android 平台的小部件不支持 WebView 以及自定义 View，包括 Canvas 的操作，所以一些复杂炫酷的图表曲线无法直接呈现 注意事项 针对小部件的进程和内存占用，有严重要求 刷新时间限制最小间隔，不同系统和厂家略有不同 由于不同设备分辨率各不同，桌面支持不同的网格模式，是否使用虚拟按键等原因，小部件最终展示并没有按绝对尺寸实现，会在不同情况下进行自适应，所以跟设计稿有一定出入；业务需要根据情况进行自适应 部分国内手机厂商对于小部件会有独立的审核机制和附加的开发规范 从 Android 12 开始，小部件有了很大的变动和改进，需留意适配 参考资料 Android UI Kit Figma 设计 https://www.figma.com/community/file/1237551184114564748 Widget 设计概览 https://developer.android.com/design/ui/mobile/guides/widgets?hl=zh-cn Jetpack Glance https://developer.android.com/develop/ui/compose/glance?hl=zh_cn 应用 Widget 开发 https://developer.android.com/develop/ui/views/appwidgets/overview?hl=zh-cn Vivo 原子组件规范 https://dev.vivo.com.cn/documentCenter/doc/834 Xiaomi 小部件规范 https://dev.mi.com/xiaomihyperos/documentation/detail?pId=1664 iOS iOS 从 iOS 8 开始支持小部件（Widget）开发，当时使用的是 Today Extension，小部件只能放在通知中心的“今天”视图中。 后来，iOS 14 引入了 WidgetKit，允许小部件直接放在主屏幕（桌面）上，并支持多种尺寸。但 WidgetKit 使用的是 SwiftUI，与 Today Extension 的 UIViewController 方式不同。 iOS 版本 开发方式 位置 主要技术 iOS 8+ Today Extension 通知中心 “今天” 视图 UIViewController iOS 10+ Today Extension 负一屏（Spotlight 搜索） UIViewController iOS 14+ WidgetKit 主屏幕 &amp; 负一屏 SwiftUI iOS 16+ WidgetKit（增强） 新增锁屏小部件 SwiftUI iOS 16.1+ Live Activities（实时活动） 新增锁屏 &amp; 动态岛（iPhone 14 Pro 及以后） ActivityKit + SwiftUI 现代 Apple 的小部件分为以下几大类场景： 锁屏界面 手机桌面 堆栈视图 手表场景 实时活动 设计 布局（Layouts）：iOS 小部件（Widget）遵循 Apple 设计规范，支持文字、图片、按钮等基础 UI 组件，使用 SwiftUI 进行布局 大小（Sizing）：官方提供了三种标准尺寸（小、中、大），不同设备的组件尺寸会有所不同，需要适配 样式（Style）：支持浅色和深色模式，颜色应与应用整体风格保持一致。组件的背景可以设置为透明，以与桌面壁纸融合 发现和推广（Discovery &amp; Promotion）：用户可以在“添加小组件”界面（长按主屏幕 → 编辑小组件）找到并添加应用的小组件 开发 iOS Widget 使用 SwiftUI 开发，并通过 WidgetKit 框架进行管理。其数据刷新依赖 TimelineProvider 进行定时更新，或者使用 WidgetCenter 进行手动刷新。 布局类型 iOS 小组件的布局基于 SwiftUI，支持 VStack、HStack 和 ZStack 进行层次排列，以及网格布局 Grid (iOS 16+)。由于小组件是静态 UI，不支持 ScrollView 或动态交互 控件类型 仅支持 Text、Image、ProgressView、Gauge (iOS 16+) 等基础控件，iOS 17 及以后版本支持 Gauge、ProgressView 等额外组件，不支持 WebView ，但可以使用 SwiftUI 的 Path 和 Shape 进行简单的图形绘制，例如绘制曲线、折线图等。 注意事项 刷新机制：小组件的更新受 TimelineProvider 限制，不能随意刷新，最小间隔一般为 15 分钟 交互限制：小组件不支持复杂交互，用户点击后只能打开 App 或触发 AppIntent 进行操作 适配性：iOS 小组件会根据设备和屏幕尺寸自动调整大小，可能与设计稿存在细微差异 平台兼容性：iOS 14 引入 WidgetKit，iOS 16 以后支持 Lock Screen Widget（锁屏小组件），iOS 17 进一步增强了交互能力，需留意不同系统的兼容 iOS Widget 适合静态内容（文本、图片、进度、绘制）。 不支持交互控件（Button、输入框、滚动列表）。 支持一定的自定义绘制（Path、Shape、Canvas）。 不能动态加载网络图片，但可以预加载到本地。 参考资料 iOS 小组件设计指南：https://developer.apple.com/design/human-interface-guidelines/widgets iOS Widgets 开发概述 https://developer.apple.com/widgets/ iOS WidgetKit 开发文档 https://developer.apple.com/documentation/WidgetKit 创建一个 Widget https://developer.apple.com/documentation/widgetkit/creating-a-widget-extension 开发 Widget 策略 https://developer.apple.com/documentation/WidgetKit/Developing-a-WidgetKit-strategy ","link":"https://liyuyu.cn/post/app-widgets-design-and-develop/"},{"title":"我的 2024","content":"现在年终总结写的是越来越晚，其实很早就想开始写的，但是总被很多事情打断。就像过去的这一年，很多事情规划了，但是却没有完成。 回望整个 2024 年，无论是工作还是家庭，可谓是近 10 年来最忙的一年了。 工作：摸索与成长 如果说去年 2023 年是我职业生涯中的重要转折点，那今年就是我真正意义上尝试角色转变的一年。这一过程充满挑战和艰辛，但也蕴含成长机遇。 四个字总结下过去一年的工作表现：差强人意。 年初，顺利通过晋升答辩，从部门“代管负责人”正式晋升为部门经理，工作范畴不变，仅仅算是给了官方正式 Title 而已吧。 为什么说刚开始自己有些地方做的并不好，毕竟做了那么多年的开发，总是习惯于亲自解决问题，习惯于用个人能力推动项目前进；慢慢到了后期，随着我涉猎的越多，很多业务盲区也被覆盖到，自然而然的多了一丝从容和信心，我逐渐意识到，团队管理的核心不是自己完成更多，而是让团队整体能力提升，让每个人都能高效地贡献价值，后面其实需要将更多精力放在目标拆解、资源协调、团队赋能上。 过去的这一年，遇到了很多人和事，让我深刻感悟到，做很多事情都是有方法论的。 游戏：难得的闲暇时刻 严格意义上，我不是一个爱玩游戏的人，手机里更是一款游戏 App 都没有，家里的 PS5 也沦为吃灰的摆设。 然而今年《黑神话-悟空》的爆火，让我也忍不住购买了它。从新手村的大头，磕磕绊绊打到现在的火焰山，一直都是用零散时间抽空玩，半年多竟然一周目还没通关。不过令我开心的是，它竟然让我找回了 10 多年前第一次玩《使命召唤-现代战争》的惊喜和震撼。单机游戏有个好处，就是玩起来没有压力，不像以前玩的《DNF》，半年不上线你就落后其他玩家了。这么多年还有一款游戏也是自己的执念：《PUBG》，一款无论从游戏机制还是射击手感，在我心中都是堪称一绝的游戏，可惜玩它的时间也是越来越少。 中国传统父母，包括我的父母辈，普遍对玩游戏持谨慎甚至否定的态度。但是随着我们这一代 80、90 开始做父母，这一观点正在改变，我们开始认识到游戏的正面价值，而不是一味的排斥。 家庭：乔迁新居 7 月份，挑了个黄道吉日，搬进新家。 其实 2023 年底买这个房子，算得上是冲动消费了，明知道房价不稳定，还是下手了。到现在，满打满算亏了有七八十个 W 了，想哭却怎么也哭不出来，自己选的路，跪着也要走完。 不过，除了房价下跌带来的伤痛，剩下的可全是开心了：我终于有自己的独立书房了，配了三米多长的书桌，满墙的洞洞板，满心欢喜。 骑行：坚持与热爱 看了下行者 App 里的年度统计，2024 年累计骑行 1384 km，运动时长 68 小时，188 次。整体运动量不如 2023 年，根本原因还是没时间，希望今年能继续坚持下去。 剁手：折腾的新东西 心心念的 M4 Pro + 48G + 1T 的 MacBook Pro 终于拿下，工作 10 多年来，第一次用上苹果本，却没有想象中的惊喜 618 老婆送我种草已久的运动相机 Insta360 GO 3S，虽然一直在吃灰，可以不用但不能没有啊 我也送了老婆一台 iPhone 15 Pro，原来她用的 12 已经肉眼可以见的卡顿，以旧换新，抵了 2000，还算不错 今年生日，老婆送我 Shokz OpenFit Air 开放式耳机，终于淘汰了 5 年多的 AirPods（续航严重缩水） 用了 7 年多的 IKBC C87 终究还是扛不住了，出现了按键失灵，遂入手京造 K3 Max 矮轴三模键盘，手感刚开始不适应，后面转为大爱 今年还入手了正点原子的 T80P 智能电烙铁，使用感受非常棒，秒杀以前用过任何一款，简直是降维打击 年初入手的红米 Watch4，小米作为最强苹果生态拥护者，消息来电通知与食堂刷卡神器，一年下来，真是便宜又好用 今年堪称剁手的一年，搬新家购置了若干电器和家具，包括但不限于：东芝系烘套装、壁挂洗衣机、石头 G20S 扫地机器人、米家智能电热水瓶、米家保险箱以及各种米家智能家居等 ","link":"https://liyuyu.cn/post/my-2024/"},{"title":"另一种 App 网页加载方式","content":"很多 App 都会有加载网页的场景 一般有如下几种方式： 跳转外部浏览器打开（简单粗暴，一行代码，但是业务形态割裂，我们自己的 App 会进入后台） 内嵌 WebView/WKWebView 实现（页面交互逻辑可控，细节可定制，为主流方式，但缺点是性能以及兼容问题，同时也无法与外部浏览器共享 cookies 等数据） Android Custom Tabs/iOS SFSafariViewController 🎉 Android Custom Tabs 基于 Intent 调用，依赖手机里 Chrome 浏览器（或基于 Chromium 内核的浏览器）实现，不同版本可能会有差异。 早在 2015 年 Google 就发布了对应的 support 依赖库，后在 2018 年迁移到了 AndroidX，更名为 browser。目前国外的主流 App 都实现了该功能，例如 X、Telegram 等，而国内却寥寥无几。 iOS 平台也提供了类似的解决方案：SFSafariViewController WKWebView 是 WebKit 框架的一部分，SFSafariViewController 是 SafariServices 框架的一部分，可让用户直接在应用内浏览网页，享受与在 Safari 中相同的网页浏览体验 - 包括密码自动填充、阅读器和安全浏览等功能，而无需离开我们的应用。 开始使用 添加依赖 dependencies { implementation 'androidx.browser:browser:1.8.0' } 判断手机系统是否支持 手机需要安装 Chrome 45 或以上版本，并且设为默认浏览器，实测 Edge 浏览器也支持 如果条件都不满足，则跳转其他外部浏览器打开 String packageName = CustomTabsClient.getPackageName(context, Collections.emptyList()); if (packageName == null) { // not supported } Intent activityIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;http://www.example.com&quot;)); PackageManager packageManager = context.getPackageManager(); List&lt;ResolveInfo&gt; viewIntentHandlers = packageManager.queryIntentActivities(activityIntent, 0); String packageName = CustomTabsClient.getPackageName(context, viewIntentHandlers, true); if (packageName == null) { // not supported } AndroidManifest.xml 处理包可见性（Android 11 及以上） &lt;queries&gt; &lt;intent&gt; &lt;action android:name= &quot;android.support.customtabs.action.CustomTabsService&quot; /&gt; &lt;/intent&gt; &lt;/queries&gt; 发起调用 String url = &quot;https://developers.android.com&quot;; CustomTabsIntent intent = new CustomTabsIntent.Builder().build(); intent.launchUrl(MainActivity.this, Uri.parse(url)); 详细特性 支持定制部分 UI 支持预热和预加载 支持最小化（画中画） 支持 ToolBar 自定义按钮 支持指定高度打开 支持设置进入和退出动画 支持传递 HTTP headers 等 优点 Custom Tabs 提供了一致的浏览体验，与 Chrome 浏览器的外观和功能保持一致，用户在使用时感到熟悉和舒适。 由于使用 Chrome 浏览器，Custom Tabs 在性能上通常优于 WebView，能够更快地加载网页。 Custom Tabs 在安全性上更强，利用 Chrome 的安全功能，例如对恶意软件的防护和强大的隐私设置。 可以利用浏览器的所有功能，包括自动填充、书签和跨设备的同步，使得用户能够享受到更全面的浏览体验。 与 WebView 相比，Custom Tabs 不需要开发者维护网页内容的呈现，减少了开发和维护的工作量。 开发者可以对 Custom Tabs 进行一些定制，比如修改颜色和添加自定义菜单，增强品牌识别度。 缺点 开发者对 Custom Tabs 的控制相对有限，无法像使用 WebView 那样对网页的行为和外观进行全面控制。 Custom Tabs 依赖于用户的 Chrome 浏览器或其他支持 Custom Tabs 的浏览器。如果用户没有安装支持的浏览器，可能会导致体验不佳。 某些特定的 WebView 功能可能无法在 Custom Tabs 中使用，例如与 JavaScript 的深度交互。 最佳实践场景 展示类：隐私协议、用户协议等 互动类：论坛、帮助手册、视频教程等 参考资料 https://developer.chrome.com/docs/android/custom-tabs https://www.chromium.org/Home/ https://developer.apple.com/news/?id=trjs0tcd ","link":"https://liyuyu.cn/post/another-app-load-web/"},{"title":"我的 2023","content":"这次年终总结比以往来得晚了些。 此刻已经到了 2024 年的 2 月初，快过年了，部分同事已经陆续请假回家了，趁着年底不忙，慢慢总结下 2023 这一年。 离职 待了七年的公司，期间动过无数次离开的念头，而这次我终于勇敢地跨出了这一步。这七年里，我买了车、结了婚、还生了两娃，我把我最美好的青春都留在了这里。从刚进来时的 Android 开发，到后面的 .NET、Angular 以及 Vue， 实现了前后端一把梭，这几年不但经历了自身的成长，也见证了公司的兴衰。 记得 2016 年公司在 A 股上市，全体上下无不憧憬着美好的未来，新来的我也卯足了干劲。但好景不长，到了 2018 年，公司进行了一次相对大规模的裁员，历史上绝无仅有，一些“能力不足”的同事走了，而我侥幸逃过一劫。在接下来的几年里，可能是由于自己的努力和机遇，虽然经历了几次架构调整和产品线变更，但好在一切都在往好的方向发展，团队相处融洽，领导也青睐，我感觉似乎可以在这里一直干到退休了。 然而 2022 年底的一通电话突然拉起了“躺平”的我，电话那头是七年前的老东家领导，他问我最近有没有换工作的想法，他那边新成立了大前端部门，负责人岗位空缺，想让我过去带团队。这一刻，命运的齿轮开始转动。 转型 时隔七年，再次回到原来的公司，早已物是人非，刚开始的一个月，我是极度不适应的，甚至萌生了退缩的念头。一是从开发转为基层管理的思维转变，团队二十多号人，很多东西都需要主动去识别和了解，否则无法支撑自己做好管理和决策；二是部门事项繁杂，累是真的累，不夸张得讲，在这里三个月的加班量比过去的七年都多；所以我不争气地怀恋起上家公司的躺平氛围。 熬过了这一年，现在回头看看，这期间的转变其实是巨大的，心态也和刚开始完全不一样了，对于这次的机会我是非常庆幸的，也不后悔。 骑行 由于换了工作，单程通勤距离由原来的 25 km 缩短为 6 km，虽然还是开车上下班，但是没了堵车，没了路怒症，带来的幸福感提升是巨大的。八月份过生日，老婆问我想要什么礼物，我说要么整辆自行车吧，我上下班骑。没想到买自行车却成了 2023 年做的最正确的一件事。为了兼顾山地车的舒适性和公路车的速度，最终选中了入门平把公路车-喜德盛极速 380。 从九月份开始，除非下雨天，几乎每天都坚持骑行通勤，6 km 骑行时间也从刚开始的 25 分钟，到后面能达到18分钟左右，体能的提升肉眼可见；每天迎着朝阳，骑到公司的大汗淋漓，运动带来的荷尔蒙提升，一扫清晨的疲惫，同时骑行带来的变化也会影响着身边的人，好几个同事也陆续加入了骑行队伍，于是我们组建了一个骑行车队，每个周末的集体骑行活动成了最大的期待。在过去的这几个月，月均骑行里程超过 300 km，2024 年，希望能有更大的挑战和突破。 折腾的新东西 今年重新回到了 iOS 平台，14 Pro Max 续航真的很顶 莫名又对养鱼产生了浓厚兴趣，399 的米家智能鱼缸体验下来没有翻车 用了多年的 DeskMini 今年终于装上了黑苹果，搭配 BCM94360CS2 网卡，与秒控板的使用，稳定得不像黑的 2018 年买的蝰蛇 2000 有线鼠标突然右键失灵，这款鼠标我是非常满意的，手感真的无可挑剔，于是决定自己动手维修，遗憾的是更换微动时不小心把焊盘搞坏，彻底报废。于是转头眼瞎看中了炼狱蝰蛇 V2 X 极速版双模无线鼠标，这名字确实很顶，但是实际体验下来，一言难尽。 今年还新增了一整套露营装备，包括：露营车、卡式炉、折叠桌椅、帐篷以及各种锅碗瓢盆等等，露营体验感爆棚 ","link":"https://liyuyu.cn/post/my-2023/"},{"title":"面试官赋能培训总结","content":"人才是关键，商业成功 = 战略 x 组织能力，所以做好人才招聘是重中之重。 公司人才价值观 聪明、乐观、皮实、自省、自律 什么情况下不招？ 工作内容不明确的 招过来没人培养的 能由内部调转岗 简单的换人需求 面试时避免的问题 有套路的问题，有标准答案的问题，容易造假的问题在面试时尽量避免，它们不能很好的让自己清楚得认识到候选人的真实情况，因为问完这些问题你可能还不能判断是否录用。 最重要的一点：业务面试官不要聊涉及薪资待遇话题。 面试之术 一场有效的面试 = 充分准备 + 过程记录 + 跟进及时 可以围绕职业发展情况、过往业绩点以及疑惑点展开。 理念淮备 企业相关 - 公司的发展史，主营业务，行业优势、技术 岗位相关 - 岗位职责，岗位工作环境、发展通道，培训福利等 数据相关 - 可提供具有信服力的数据 2 分钟氛围创设和自我介绍 15-60 分钟专业背景、过往行为、动力适配以及其他信息 2-5 分钟候选人提问，提供关于职位的补充信息 面试时直接在简历上做记录，圈好关键字，最后做好面试评价，为下一轮面试官做提供数据支持。 面试之器 情景面试法 复盘过往，换位思考，假如你是 xxx，你会怎么做才能让结果更好？ STAR 面试法 Situation 情况为什么 Task 任务目标是什么 Action 行动怎么做的 Result 结果怎么样 压力面试法 细节追问、故意找茬、指出失误、时间压力 Probing 面试法 其目的是深入挖掘和了解面试者的经验、技能和适应性。这种方法通常涉及提出开放性问题，以激发详细的回答，以便更全面地评估候选人的能力和适应性。 3W 面试法 侧重于收集求职者的工作经历和能力。&quot;3W&quot; 代表 What（做了什么）、Why（为什么这么做）、和结果（取得了什么结果）。 大五模型 开放性 尽责性 外向性 宜人性 情绪稳定性 ","link":"https://liyuyu.cn/post/summary-of-interviewer-training/"},{"title":"我的 2022","content":"这一年，过得有多苦，恐怕只有亲身经历的人才能体会。 2022 年初的一波疫情，让原本有序的生活变得一团糟，快递停摆、居家办公、全员核酸，搞得人心惶惶。然而回头看，竟有点怀念那种生活，谁又能想到，现在以这种方式结束，就像那轰轰烈烈的爱情，说散就散了。 爷爷走了 年初爷爷意外摔倒，住进了医院，一待就是一个月，没有半点好转的迹象，临近春节，奶奶叮嘱我，今年无论如何一定要拍个全家福照片。大年初六，在姑姑家新房里，拍了最后一张满员的全家福，一个月后，爷爷与世长辞，我从苏州赶回去，送了他最后一程。 意外的手术 去年八月公司体检，发现右侧甲状腺结节，体检中心说问题不大，定期复查就行，于是没太放在心上。今年三月份，咽部突然有异物感，10 多天都没有好转，心里慌了，担心是不是结节长大了？好在几天后，异物感好转，加上疫情原因，就没有去医院，最终不了了之。时间一晃来到了今年六月初，咽部又突发异物感，这次没有犹豫了，直接去了医院，确诊 ACR TI-RADS：5 级，结节实质钙化。在咨询了医生后，决定手术切除。手术那天的场景我这辈子都不会忘记，去往手术室的路上，天花板和灯光在眼前飞速划过，不停变换，就像人生的一场幻灯片，而我从未看过。好在手术很成功，术后恢复也很好，休息了两周就回公司上班了。挨了一刀，带来了更多的感悟和思考，我觉得是幸运的，身体才是革命的本钱啊！ 幼儿园 今年小橙子三周岁了，到了上幼儿园的年纪，然而对于一天早教和托班都没上过的他，我又是忐忑和紧张的。父母和孩子一样，都有分离焦虑，开学的第一个星期我们都过得很痛苦，每天老师发的照片里他都在哭，不合群，甚至连续三天尿湿裤子，想想又心疼，但又不得不放手成长。不过令人欣慰的是，一切都在第二个星期得到好转，他开始积极参与集体活动，吃饭睡觉都很乖，老师反馈互动表现都很棒，老父亲终于长舒了一口气。 躺平的惊喜 来公司的第 7 个年头，今年没有了以往骚动的心，可能也是因为生了二胎的缘故，动不了也动不起。今年的工作内容没有任何变化，身边的一切也都是老样子，但好在领导看来，我是兢兢业业的，对得起自己，也对得起公司。我以为今年又这样趟过去时，年底的一封加薪邮件，让这阴冷的冬天多了一丝暖意和惊喜，明年好似又多了一份期待啊，加油，打工人。 学习和创造 今年业余时间捣鼓了两个新 App，《一剪没》以及《扫你码》，都是基于 Android 最新技术体系，比如 Jetpack Compose。明明工作内容已经不涉及 Android 了，但我还是怕把它弄丢了，这可能也是一种偏执。 最开心的事 今年最开心，最传奇的事莫过于帮老爸找回被偷的手机了，简直堪称奇迹，能吹几百年的牛逼。 折腾的新东西 年初把新区的房子重新装修了一遍，疫情原因，陆陆续续搞了半年才完工，家里多了很多智能家居设备，用起来很是满意。 为了配合智能家居，购置了一台小爱音响 Pro，并改装了射频模块，啥都能控制了。 6 月份老婆送了台 PS5，心心念了很久，然而玩游戏的时间却很少，不过即使看到它在那儿吃灰我也很满足。 11 月在日本亚马逊海淘了一个 Apple TV 2022，观影体验那叫一个绝，遥控器简直爱不释手。家里的 N1 刷了 OpenWrt 系统，在家随时随地的科学上网，也算是继续发光发热。 今年换了 4K 显示器，装了一台净水器，这些可有可无的东西，带来的生活品质提升却是很大的。 今年拼多多买了一部入门 HiFi 耳机，飞利浦 SHP9500，音质好到爆。 今年还给 NAS 扩容了一块 4T 硬盘，满满的安全感。 今年最大的一笔开销莫过于给妻儿老小配置全套商业保险了，花钱买安心，以备不时之需。 写在最后 2012 年大学毕业至今，一晃整整 10 年过去了，曾经的少年已是中年大叔，也被生活磨平了棱角，下一个 10 年又会怎样呢？ ","link":"https://liyuyu.cn/post/my-2022/"},{"title":"扫你码","content":" 一个可能让你在微信里更舒服地扫码小工具。 当我们在微信里吃瓜，或者查看朋友分享的一些好东西时： 长按识别二维码后，经常会遇到以下几种情况，这严重影响我们的使用体验： 此时我们只能保存图片到本地，然后再打开对应 App 去识别这些二维码。如此繁琐的操作背后，究其原因无非就是大厂的生态壁垒以及国内互联网的内容审查，有没有一种更加快捷的方式，实现即时在屏幕上扫码，也不局限于微信？答案是有的。 技术原理 利用录屏 MediaProjection 获取到当前屏幕画面，然后 ZXing 识别其中的二维码，最后打开网页，一气呵成。理想和现实的差距就体现在：如何在微信里一触即发？ 悬浮窗按钮（可以实现，但是涉及权限和视觉污染，有点不妥） 通知栏常驻（可以实现，但下拉通知栏然后再点按，差点意思） 摇一摇触发（可以实现，但涉及应用保活以及其他应用冲突问题） 侧边栏快速启动（堪称国产 ROM 一绝，从我自己使用的 OriginOS Ocean 到测试机的 MIUI 13，都是支持的，用过这一功能，iPhone 真的就回不去了） 其实还有类似的“悬浮球”功能也能快速打开指定 App，每家手机系统可能实现不一，但是原理都是一致的。 各大 App 分享的图片二维码内容几乎都是 URL，我们只要调起外部浏览器打开就能突破微信的限制，实现吃瓜自由。由于 Android 11（API 30）调整了软件包可见性，当应用 targetSdkVersion &gt;= 30 时，需要在清单文件中添加 &lt;queries&gt; 元素进行适配，否则无法调起外部浏览器。 最后把 Activity 的背景色改为透明，修改默认的进入和退出动画，这样在打开时就不会有明显的割裂感了，堪称完美，一个全新的“扫你码”App 就此诞生。 项目地址：https://github.com/li-yu/FuckWxScan 使用方法 安装后，把 App 加入侧边栏快速启动，具体方法每家系统大同小异。 在需要扫码的界面，通过侧边栏打开扫你码，冷启动时屏幕会有提示，点击“立即开始”即可，后面 再次扫码不会有提示。 当成功识别到二维码后，会有吐司提示，并通过外部浏览器打开。 演示效果 ","link":"https://liyuyu.cn/post/fuck-wx-scan/"},{"title":"老爸手机被偷始末","content":"8 月 28 号上午，一个陌生的来电打破了本该属于周末的轻松氛围，是老爸，借朋友的手机打给我，说手机刚被偷了，听得出来他很慌张。我安慰了下，让他不要担心，首要的事情是去补办手机卡（一张电信，一张移动），随后便挂了电话。 丢失模式 老爸用的手机是红米 K40，我依稀记得去年给他设置并登录了小米云服务，抱着试试的心态，我登录了小米云服务，值得庆幸的是，他的小米账号密码竟然是我常用的密码（其实我都忘了我设置的啥密码了），凭直觉一次就登录成功，然后便是查找设备，然而手机早已关机，最后一次定位显示在老爸上班的地方，时间为 8:57，最后我打开了丢失模式，留下了我的号码。 补卡风波 大概半小时后，接到了老爸电信卡打来的电话（身边有个旧的坚果手机备用），告知电信补卡成功，而移动的却补卡失败，移动异地补卡被要求提供三个月内通话记录，由于平时联系都是电信卡，移动的因为绑定了多张银行卡，遂改成8元套餐当副卡使用，根本没法提供通话记录。于是没办法，只能先打电话给归属地 10086，进行了紧急停机。根据客服指引，下载中国移动 App，进行了在线补卡操作，期间由于微信和支付宝都是绑定的移动卡，5 元补卡费的支付陷入了死循环，好在最后通过我的银联卡完成了支付。 报警 一通操作后，我才让老爸进行了报警，警察来后，询问了丢失经过，便走了，其实这会儿已经不抱任何希望了。毕竟丢手机这件事，我觉得老爸也有责任，据他描述，早上接了老板一个电话，随手放在桌上，然后去倒了杯水的功夫（隔壁房间），前后不超过 5 分钟，回来就发现手机没了。由于事发楼层没有监控，人员也杂，一时也毫无头绪，我让他安心等警察破案。 了无音讯 说实话，我自己也对找回手机没有信心，身边太多这样的案例了。往后的几天，我时不时的就打开小米云服务网站看看手机定位，都魔怔了，倒不是心疼这 2000 多的手机，而是这件事让老爸慌得不行，担心银行卡的钱，担心微信里的钱，他觉得他辛辛苦苦赚的钱都会没有了，我说不会的。两天后，他收到了邮寄过来的移动 SIM 卡并完成了激活，这期间，小米云服务也一直没有显示新的定位信息，我以为这件事就这么过去了。 意外的短信 【小米】您丢失的M2012K11AC手机已于2022-08-31 12:04:21上线，可访问i.mi.com使用查找手机功能定位丢失的手机。 三天后的 31 号中午，我刚吃完午饭，突然一条短信让我血脉膨胀，本着警惕的原则，加上钓鱼短信很多，我随即登录了网站，确认了定位信息，然后立马打电话给老爸，告知了他位置，是一家手机店附近，距离事发地大约 12 公里，不算太远，我让他赶紧过去。卧槽，说实话，我这会儿激动到说话都是颤抖的，有种破案后仿佛胜利就在眼前的感觉。 手机店的线索 大约 13 点左右，老爸赶到了这个手机店，不得不服小米的定位信息很准确的，营业员说刚才确实有个人过来解锁手机，说是刚买的手机，不知道怎么操作锁起来了，但是这家手机店最终解锁失败，说 10 几分钟前刚走，让其提供监控信息，营业员表示拒绝，我们也能理解，没再多废话，于是便报警。警察来后，顺利调取到监控，拿到了录像和嫌疑人的截图，由于摄像头是俯视，正面拍的不是很清楚，但是大概体貌特征是可以掌握了，男性，白色T血，年纪大概 40 左右。警察说，证据会交由事发地派出所继续处理，说完便走了。（后话：这家手机店其实明明知道手机是偷的，毕竟丢失信息都显示在屏幕上，不过大部分人都会选择无视的） 神助攻 中午的亢奋劲头消去，下午整个人都昏昏沉沉的。17 点左右，一个归属地显示浙江金华的电话打了进来，对方表示是xx手机店老板，说刚才有个人来店里解锁手机，发现屏幕上留有我的丢失信息，疑似偷盗机，想进一步确认下，并表示已记录了“嫌疑人的信息”：名字和手机号码，并告知了店铺位置也表示会积极配合调查。我把掌握的信息发给老爸，让他直接去派出所，让民警处理，不要私自联系。不得不感慨，这世间还是有好人的。事已至此，直觉告诉我，快结案了。 嫌疑人的来电 接完手机店老板电话大约 20 多分钟后，一个电话打了进来，号码正是店主提供的“嫌疑人”的，一开口对方就表示前几天在万达广场捡到一个手机，问是不是我的，并问我现在在哪儿，要立马给我送过来。听得出来，对方很激动也很紧张，但是这番操作是我万万没想到的，我没多说什么，毕竟对方愿意归还手机，随即让他送到事发地派出所，对方表示半小时送到。 拿到手机 半个多小时后，老爸顺利拿到手机，钢化膜、手机壳以及 SIM 卡不见踪影，好在手机完好无损，顺利解锁后，发现已被刷机，资料全无。 剧终 回顾整个事件，最关键的一点就是遇到了一个好人店主，以及给老爸的手机开启了查找设备功能，最终能顺利拿回手机，简直堪称奇迹。至于对方为啥突然这么急的归还手机，竟然是被手机店主吓的。虽然用了一年多的 K40 值不了几百块，但是事后老爸还是买了点水果专程上门进行了感谢。最终从店主口中的得知了原委：小偷下午到达了这个手机店，拿出手机让解锁，店主看到锁屏丢失信息后表示这种丢失模式很难解锁，并委婉询问这个手机的来历，对方表示是自己的。因为解锁刷机需要时间，店主表示可以把手机留在店里，等解锁成功后通知对方来取，对方同意，留下了姓名和电话便离开了。谁知仅仅过了几分钟，对方竟折返取了回手机，表示不解锁了。等对方走后，店主根据锁屏上的电话信息联系到了我，在和我通话后，店主也联系了小偷，表示他这个手机是偷的，失主已经报警定位到了店铺位置，警察过来办案追回和自己主动归还性质是不一样的，估计会被判个半年几个月啥的，让对方考虑清楚，于是便有了后面小偷主动联系我的情节。 ","link":"https://liyuyu.cn/post/amazing-phone-story/"},{"title":"一剪没","content":"一个可能让剪贴板只被使用一次的 Android App。 初衷 谷歌从 Android 10 开始禁止后台应用读写剪贴板，这一定程度上改善了剪贴板的滥用情况，但是我们仍能看到，在打开某些应用时剪贴板被疯狂读写，除了塞一堆乱七八糟的进去，此外如果剪贴板里存在一些手机号、身份证号以及详细地址等个人隐私信息的话，无疑是会被其读取的，至于它们拿来干嘛只有鬼知道。 目标 日常粘贴动作完成后立即清空剪贴板，防止被其他程序读取。 复制动作后，如果 15 秒内没有进行任何粘贴动作，同样执行清空操作。 实现原理 借助无障碍服务 AccessibilityService 监听全局复制、剪切和粘贴的点击事件。 无障碍服务下不需要申请权限即可实现悬浮窗。 透明悬浮窗获取到焦点后（App 进入前台）即可进行剪贴板操作，这对于用户是无感知的。 另一种监听复制事件的方法： // 和以前一样，App 同样需要实现以下方法监听剪贴板的变动事件 clipboardManager.addPrimaryClipChangedListener { // 当 App 在后台时，Android 10 以后虽然无法正常回调此方法， // 但是系统会产生报错日志，我们捕获这个报错日志即可 // 注意：需要赋予 android.permission.READ_LOGS 权限才能抓到日志（部分手机无效） } 注意事项 允许拥有通知权限，开启前台服务提高存活几率。 允许自启动，每家手机厂商设置方式不一样，但大同小异。 多任务列表 App 加锁也是提升存活率的好办法。 vivo 系手机一定务必开启：设置-&gt;电池-&gt;后台耗电管理-&gt;允许后台高耗电，否则服务无法正常运行。 执行 adb -d shell pm grant cn.liyuyu.oneclipwiping android.permission.READ_LOGS，部分手机即使赋权后，也不能捕获到 logcat，比如 vivo 系。 当发现无障碍服务已经开启，但还是无法正常工作时，请尝试重启手机，屡试不爽。 已知问题 微信聊天界面的输入框以及聊天列表均重新实现了 ContextMenu，遗憾的是，无障碍服务竟然拿不到其复制和粘贴的点击事件，所以目前只能依赖于复制后系统 Toast 提示的 “已复制” 或者借助 READ_LOGS 来监听，然后等待指定时间后清空剪贴板。 ","link":"https://liyuyu.cn/post/one-clip-wiping/"},{"title":"我的 2021","content":"这一年发生了很多事情，陪小橙子的时间也越来越少，时间、精力和金钱让我变得很焦虑。 意外的二胎 今年小橙子两岁了，懂的越来越多，睡觉也越来越乖，带起来愈发省心。然而舒服的日子不长，3 月底，老婆意外怀孕，知道的那一刻我俩除了惊喜更多的是焦虑，刚度过小橙子最难熬的 2 岁，又来一个神兽，那画面不敢多想。没有了第一胎时的激动和喜悦，我们开始思考和权衡，二胎的意义是什么？万一又是个儿子怎么办？谁来带？我和老婆都是独生子女，很多时候都希望把全部的爱给小橙子一个人，独享的爱。 You can't have your cake and eat it. 我知道，不管怎么选，最终都会后悔。然而最后还是选择了一条最艰难的路：生二胎。没有任何悬念和意外，11 月底小儿子出生，直到现在我还是没法释怀，我竟然有了两个儿子。家里突然多了一个新成员，小橙子的敏感比我们预想的强烈些，如何正确处理他的情绪又成了一个头疼的问题。 一年一度的体检 今年参加了公司年度体检，发现了一堆小毛病，这些年都没怎么重视自己的身体状况，运动几乎没有，体重日益增加，带来的副作用也很明显。人有时就这样，不体检根本不知道身体的严峻形势，于是 9 月份体检完开始跑步和控制饮食，体重也从 80kg 降到现在的 77kg，效果还是有的，不过离目标还很远。体检带来的连锁反应还有对父母身体的担忧，下半年，也抽空带父母进行了一次体检，同样小毛病一堆，到了他们这个年纪，健康比什么都重要。 “被动”的躺平 今年是来公司的第 6 个年头了，真没想到一待就是这么久。年初筹备了很久的面试学习，被意外的二胎打乱节奏，眼下公司的 955 和宽松的工作氛围能让我在家庭和公司间找到很好的平衡点，于是又又又撑了一年。今年整体的工作内容还是前后端一把梭，以及维护零星的几个 Android 项目，没有任何挑战性。呆久了真的有惰性，想动却又不敢动，顾及领导的想法，担心未来的变数，只能苟活在眼下，挺怂的。 学习与收获 今年利用空闲时间整体学习了下 Jetpack Compose，同时做了一个相册管理的 App，自己一直使用着。得益于 Kotlin 语言，Jetpack Compose 带来的编程体验是很棒的。虽然工作内容越来越远离 Android，但是初心不改，Android 依旧是我梦开始的地方。 折腾的新东西 年初为了体验 Android 生态，卖掉了使用多年的 iPhone 8 Plus，入手了 IQOO Neo5，在高刷屏和快充的加持下，这一年体验下来很满意，除了平平无奇的 OriginOS 和渣渣的相机。 今年给 DeskMini 小钢炮 CPU 升级到了 i9-9900T，8C16T 数框框很爽，内存也升到了 32GB 了，写代码 Bug 又能少些了。 在家吃灰多年的 N1 盒子，今年被我正式解除封印，刷了 CoreELEC 系统，搭配 X1 芯片的大法电视播放 4K 蓝光，流畅的不像 100 块的东西，堪称神器，同时意外发现 Sony 的电视遥控器竟然能直接控制 N1，惊喜不已，体验直接拉满。背后的原理竟是 HDMI-CEC，孤陋寡闻了。 前段时间在黑群晖上搭建了 Calibre-Web，把百度网盘上 1T 多的电子书资源下载下来，导入了进去，期间踩坑无数，不过最终都完美解决了，配合 Kindle 推送，书籍的查找和阅读体验都很好。书可以不读，但不能没有，哎呦，感觉自己又“骚”了。 今年还新添置了 iPad Air4 和 戴森 V10 slim 吸尘器，过生日的时候，老婆送了一台 kpw 4，都挺好使的。尤其是那个买奶粉送的杂牌空气炸锅，配上山姆的牛角包和烤肠，堪称一绝，后悔没早点用起来。 写在最后 今年依旧是想法多，行动少的一年。新的一年希望能有所改变吧，多陪陪家人，多读读书，少刷抖音。害！加油吧，中年人！ ","link":"https://liyuyu.cn/post/my-2021/"},{"title":"群晖 Calibre-Web 折腾记","content":"这些年书没看几本，到处搜刮整理的电子书资源却达到了惊人的 1T 多，检索和查找书籍成了一个头疼的问题。书可以不看，但不能没有，于是开启了庞大的电子书整理之旅。 1. 下载 所有书籍资源都存放在百度网盘里，想靠百度那点小水管不知道要下载到何年马月，于是充值了 SVIP，期间却因为各种文件名过长、违规资源等等导致了很多文件下载失败，修复路径以及在线解压再下载等手段，陆陆续续花了 2 天时间才下载好，但也舍弃了不少“违规”资源，多少还是有一点遗憾。 2. 解压和清理 下载完后用 C# 写了个控制台应用递归遍历解压了各类 zip 以及清理了空文件夹和脏文件（比如百度网盘生成的 .downloading 文件），然后利用 dupeGuru 扫描清理了重复文件。 3. 导入 Calibre Calibre-Web 的运行依赖于 Calibre 生成 metatde.db 的数据库配置文件，所以先在电脑上安装 Calibre，然后在群晖里新建一个文件夹用于 Calibre 应用目录，最后作为远程文件夹挂载到本机供 Calibre 使用，切记赋予这个文件夹 Everyone 读写权限。 所有书籍导入 Calibre 是一个极度漫长的过程，耗时数十个小时，因为每本书都需要读取元数据生成封面等信息，暂时没有找到快速导入的方法。此外在以 从文件夹和子文件夹添加书籍 方式批量导入书籍时，提示 多文件图书？ 对话框，不同的选项，结果也不同： 原始文件夹如下，共 6 本书籍，其中 3 本是包含多种格式（mobi + epub + azw3）： 选择 是，导入了 4 本 选择 否，成功导入了 6 本 从结果看，选择“否”之后导入了全部书籍，是我们想要的结果，官方是这样描述这个功能的： Calibre 假设每个文件夹包含一本书。一个文件夹中的所有电子书文件都假定是同一本书，只是格式不同。 4. 安装 Calibre-Web 网上流行的一些教程都是推荐 technosoft2000/calibre-web 这版 Docker 镜像，功能全面。但经过我安装测试后发现了一些问题，比如单独进行格式转换或者邮件推送 Kindle 是没问题的，但是两者一旦结合，转换并推送 Kindle 时就会失败，翻看了源码，发现在处理邮件发送时，获取待发送的书籍路径多了一层，导致找不到文件。此外还有豆瓣获取元数据的 API 失效，经常卡死，镜像作者也指出没有时间维护了，遂放弃。最终选择了 linuxserver/calibre-web，并完美解决了各种问题。 群晖 Docker 创建容器很简单，基本一路 Next 就可以跑起来了，也可以参考这篇教程。 linuxserver/calibre-web 前期使用正常，除了每次启动容器有点慢，整体还是可以的，后期随着 calibre 升级到 v6，群晖内核不支持了，导致格式转换报错，于是选择了 johngong/calibre-web，一个国人维护的版本，很多功能都集成了，开箱即用。 5. 添加格式转换功能 linuxserver/calibre-web 版本镜像没有书籍转换功能，需要在创建容器时新增环境变量 DOCKER_MODS=linuxserver/calibre-web:calibre，切记一定是创建容器时添加，如果创建后再添加，大概率会失败。 启动后登录 Calibre-Web，在权限管理 -&gt; 扩展程序配置 -&gt; Calibre 电子书转换器路径 填写 /usr/bin/ebook-convert，保存即可。 johngong/calibre-web 版本自带，无需额外设置。 6. 设置正确的时区 新增环境变量 TZ=Asia/Shanghai 重启容器即可。 johngong/calibre-web 版本自带，无需额外设置。 7. 添加新的豆瓣 API 新版 Calibre-Web（0.6.14）移除了 douban-api，国内不科学上网的话无法搜索书籍的元数据，网上找到一个解决方案：calibre-web-douban-api，复制 src/NewDouban.py 到 calibre-web/cps/metadata_provider/ 目录下，重启项目即可。 也可以直接下载后通过 Docker 的卷映射挂载到 /app/calibre-web/cps/metadata_provider/NewDouban.py 目录即可，效果是一样的。 如果遇到搜索元数据时容器卡死，可以删除 /app/calibre-web/cps/metadata_provider/ 下其他源，只保留我们新增的这个豆瓣源，然后重启容器即可。 Ps. johngong/calibre-web 版本设置 ENABLE_DOUBAN_SEARCH=true 环境变量即可。 最新版 johngong/calibre-web 需要把 usr/local/calibre-web/app/cps/metadata_provider 下所有搜刮器删除然后使用新的豆瓣搜刮器，执行下 wget -P /usr/local/calibre-web/app/cps/metadata_provider https://raw.githubusercontent.com/fugary/calibre-web-douban-api/main/src/NewDouban.py 或者也可使用上面提到的卷映射，效果是一样的，最后重启容器即可。参考 8. 开启在线阅读功能 linuxserver/calibre-web 版本默认没有开启该功能，前往 权限管理 编辑对应用户权限，勾选 查看书籍 选项即可。 johngong/calibre-web 版本自带，无需额外设置。 9. 配置 Kindle 推送 首先进行 SMTP 邮件服务器设置，具体可以参考邮箱服务商的帮助文档，比如我用的 QQ。然后前往亚马逊，管理我的内容和设备 -&gt; 首选项，获取对应设备的 Kindle 邮箱地址，并设置发件人白名单。最后在 Calibre-Web 里 接收书籍的Kindle邮箱地址 填写即可。 Ps. 国内的推送服务还能使用 2 年，到时候估计得切到美区了。 10. 更新的注意事项 所有版本的 calibre-web 都不推荐在网页内自动更新程序，可能会出现莫名其妙的问题。其实更新容器也很简单，我们只要导出容器设置文件（端口设置、环境变量等都会保留），然后删除容器，更新镜像后通过导入配置文件重新创建容器，所有资料和配置都还在，分分钟就搞定了，当然也可以使用 Watchtower 来自动更新 Docker 镜像与容器。 11.database disk image is malformed 更新元数据时不当的操作可能会导致数据库损坏，后续所有的保存都会提示 database disk image is malformed ......，此时可以尝试使用 SQLite Expert Professional 5 对 metadata.db 进行修复，然后使用修复后的 db 文件覆盖替换就行。 ","link":"https://liyuyu.cn/post/synology-calibre-web-jour/"},{"title":"Android 和 Java 的那些事","content":"Java 语言应用非常广泛，最近几年更是快速迭代更新，那么 Android 的发展是否与之息息相关呢？身边很多人，包括我自己对于它们之间乱七八糟的关系也产生过很多疑问，希望这次能一一解惑! 阅读受众：新人或者困惑者 文章涉及环境：Android Studio Arctic Fox | 2020.3.1 Patch 4 文字里提到的 Java 版本均为：JavaSE（Java Platform Standard Edition）Java 标准版 文章更新时间：2021-12-15 21:00 JDK、JRE、JVM 以及 OpenJDK 到底是啥？ JDK(Java SE Development Kit)，Java 标准开发包，它提供了编译、运行 Java 程序所需的各种工具和资源，包括 Java 编译器、Java 运行时环境，以及常用的 Java 类库等。 JRE( Java Runtime Environment) 、Java 运行环境，用于解释执行 Java 的字节码文件。 JVM(Java Virtual Mechinal)，Java 虚拟机，是整个 Java 实现跨平台的最核心的部分，负责解释执行字节码文件，是可运行 Java 字节码文件的虚拟计算机。 OpenJDK，可以简单理解为一个开源并更加自由的 JDK，区别可以归纳为以下几点： 授权协议的不同 OpenJDK 不包含Deployment（部署）功能 OpenJDK 源代码不完整 部分源代码用开源代码替换 OpenJDK 只包含最精简的 JDK 不能使用 Java 商标 Java8、JDK8 以及 JDK1.8 傻傻分不清楚，到底是什么鬼？ 这个问题一直困惑着不少新手，其实可以简单地把它们理解为同一个东西（体系），由于历史原因，这种混乱的命名方式目前仍持续影响着： 比如 Gradle 7.0.2 源码中是这样描述 Java 版本的： 而 Kotlin 中是这样描述 JVM 的： -jvm-target version Specify the target version of the generated JVM bytecode. Possible values are 1.6 (DEPRECATED), 1.8, 9, 10, 11, 12, 13, 14, 15, 16, and 17. The default value is 1.8. 上图中的 Java 9，Gradle 称之为 VERSION_1_9，也就是我们常说的 1.9，而 Kotlin 直接成为 9，其实都是同一个东西，不同的编译（构建）工具或者框架体系中别称不一样而已。 伴随着 Java 的迭代发展，这个问题也在逐步改善，目前从 Oracle Java 官网来看，命名已趋于统一，就连以前老的版本的名字都改过来了，变成了JDK7，JDK8 这种形式，不再是之前的 JDK1.7 以及 JDK1.8，至于新的，比如 Java 17，肯定再也不会出现 1.17 这种奇怪的名字了。 为啥出现了 OpenJDK？ Android Studio 2.2 首次捆绑 OpenJDK8，也就是从那时候开始我们的电脑不需要额外安装 JDK 就能运行 Android Studio 了。 Oracle 起诉谷歌在 Android 上使用 Java 代码侵犯版权和专利权是谷歌参与 OpenJDK 项目以及捆绑 OpenJDK 到 Android Studio 的导火索，其实再看看 OpenJDK 和 Oracle JDK 的区别，就自然明白谷歌的心思了。 Gradle 是什么？ Gradle 是一个基于 JVM 的构建工具，不是编程语言！它见证和陪伴了 Android Studio 的成长，但由于 Gradle 不单单服务于 Android 的开发构建，因此谷歌开发了一个 AGP(Android Gradle Plugin) 插件，添加了几项专用于构建 Android 应用的功能。虽然 AGP 插件通常会与 Android Studio 的更新步调保持一致，但 AGP 插件（以及 Gradle 系统的其余部分）可独立于 Android Studio 运行并单独更新。 为了和 Gradle 的版本匹配，目前最新的 AGP 跳过版本 5 和 6 直接进入了 AGP 7.x 版本。 AGP(Android Gradle Plugin) 也需要 JDK！ 毋庸置疑， AGP 的运行肯定是需要 JDK 的，随着 AGP 的迭代，所需的 JDK 版本也随之变化。最新 Android Studio 使用 AGP 7.x 构建应用时，需要 JDK 11 或更高版本才能运行 Gradle。由于最新 Android Studio 捆绑了 JDK 11（OpenJDK 11），并将 Gradle 配置为默认使用 JDK 11，这意味着大多数 Android Studio 用户不需要对项目进行任何配置更改。 如果使用的是独立于 Android Studio 的 AGP，需要将 JAVA_HOME 环境变量或 -Dorg.gradle.java.home 命令行选项设置为 JDK 11 安装目录。 需要注意的是，上面所说的 JDK 版本是运行 AGP 所需的，不是我们开发编译业务代码所需的 JDK，两者是独立配置的。最新 Android Studio 也为了区别开，专门新增了一个 Gradle JDK 的配置项： 为什么说 Java 8 是一个里程碑？ 要知道，Java 17 都正式发布了，但根据调查显示，80% 的受访者仍然在使用 Java 8。目前受 Oracle LTS 的版本只有 Java 8，Java 11 和 Java 17，而 Java 8 的截至支持时间更是达到了惊人的 2030 年 12 月。 首先从 Oracle JDK 8u211 开始往后的版本，都需要商业收费，但我觉得这不是最重要的原因。Java 8 中终于引入了 Lambda 表达式，写过 C# 或者 Kotlin 的应该都知道，这东西写过就回不去了，除此之外，还有支持重复注解以及新增 Stream 和 Optional 类数据处理等等，这些 Java 8 开创性的语言特性还在持续渗透影响着，在 Java 8 之后的一些版本，新特性不痛不痒，也没有足够的说服力让我们去更新，要知道，生产环境越稳定越好。 目前在最新 Android Studio 新建工程时，无论选 Java 还是 Kotlin 语言，都是默认 Java 8 编译环境： compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } kotlinOptions { jvmTarget = '1.8' } Kotlin 的本质是什么？ Kotlin 是一种在 Java 虚拟机（JVM）上运行的静态类型编程语言，本质上和 Java 一样，都会编译成 Java 字节码运行。Koltin 和 Java 100% 互操作，且 Kotlin 开发之初就以兼容 JDK 6 为目标，因此很多老旧系统的设备都能运行，无须担心其兼容性。此外，Kotlin 在空安全、懒加载、高阶函数、协程、inline 操作符等等新特性以及语法糖的加持下，用过就真的就回不去了。 Desugaring（脱糖）的目的 由于不同的 Android 版本所支持的 JVM 版本也不同，所以在使用不支持的高版本 Java 语法时，需要在编译期转换为其支持的低版本 Java 语法，这一过程称为 Desugaring（脱糖）。 Android 的脱糖发展史经历了早期的 javac&amp;ProGuard 以及 Retrolambda 到后来的 Jack&amp;Jill 编译器，再到最新的 D8&amp;R8，其实脱糖的核心目的只有一个：让所有的 Java 语言新特性都能运行在所有设备上。 Android Studio 目前已支持大部分 Java 8+ APIs 且不需要指定 App 的 minSdk 最低版本，这就是通过 D8 脱糖实现的。 但是 D8 也不是万能的， 它只为我们提供了部分核心的语言特性支持。 Android 开发能用最新的 JDK17 吗？ 很遗憾，截至目前，在我尝试前往 Project Structure -&gt; SDK Location -&gt; Gradle Settings -&gt; Download JDK ，下载并设置最新的 JDK 发行版本（推荐 Oracle OpenJDK 17），然后设置 compileOptions 为 JavaVersion.VERSION_17 并且设置 compileSdkVersion 为 30 及以上，Kotlin 的工程还需要指定 jvmTarget = '17' ，一顿操作之后，编译报错，提示 Unsupported class file major version 61。 目前 AGP 最新版为 7.0.4，其依赖的 Gradle 为 7.0+，而要支持 Java 17 则需要 7.3+，所以暂时没戏了，后期升级应该是可以的。 最后经测试 AGP 7.0.4 + Gradle 7.0.2 + Java 11 是没毛病的。 参考文献 JDK、JRE、JVM三者间的联系与区别 What is the difference between JVM, JDK, JRE &amp; OpenJDK? Google vs Oracle 专利侵权案始末 Android Gradle 插件版本说明 ","link":"https://liyuyu.cn/post/android-and-java/"},{"title":"我的 2020","content":"上周在公众号得知郭神要去苏州微软了，祝福的同时也感慨万千。2014 年的《第一行代码 第 1 版》，这本书彻底结束了我为期两年半的测试工程师生涯，2015 年初我辞职，离开深圳回到了苏州，正式走上了 Android 开发之路，然而。 然而今天，我不得不又借助相册回顾了即将过去的这一年，这一年平淡无奇，除了小橙子带来的快乐，其他的就什么都没有了。 这一年小橙子从牙牙学语到蹒跚学步，每天嘻嘻哈哈，蹦蹦跳跳，作为父亲累并快乐着，能参与到孩子的成长过程我觉得是值得的。不过这也带来了一个问题，就是属于自己的空闲时间越来越少。刚刚过去的周末，原本打算趁着年底公司项目不忙，看看书敲敲代码，做做技术储备，然而事与愿违。溜娃、做饭、家务一顿操作下来，只想静静地躺在沙发上刷手机。 这一年原本计划了很多，但却很多都没有完成。年初公司组织架构又变动了，来公司快 5 年了，几乎年年一变，每次我的工作内容都会随之改变。这期间也有过无数次离职的念头，可能是受新冠疫情的影响，可能是公司 955 的舒适环境，也可能是领导贴心的关怀，我最终熬到了现在。这一年工作内容主打 B/S 架构产品的开发，新涉猎了诸如 AngularJS、Vue.js 以及 .NET Core 等框架，公司的销售和研发模式也决定了每个人都是前后端一把梭，虽然有点杂，但至少拓宽了自己的技术栈。从进公司的一个纯 Android 开发混成现在这样，我不知道是该哭还是笑。 这一年给家里人换了一圈的新手机，而自己还在坚持 64GB 的 8P，天才吧换了新电池，应该还能大战一年。这一年牺牲了不少周末时光在副业上，收获也还算可以。这一年新添置了面包机、智能门锁以及我心心念的 DeskMini，幸福指数当然有了。这一年，看似平淡普通，却又充满了遗憾和不甘。 我庆幸自己有着良好的学习能力，每次被动的改变，都能从容不迫。但是自己的主动改变却越来越少，或者说是害怕改变了，害怕换工作，害怕新的开始。很久没有那种感觉了，那种走路带风，那种充满未来可期的感觉。 年底了，一些奇奇怪怪的想法又冒了出来，这次又会是怎样的结果？ ","link":"https://liyuyu.cn/post/my-2020/"},{"title":"我的 2019","content":"和往年一样，又到了写年终总结的时候，这一年发生了很多事情，最开心就是儿子出生了。 年初老婆孕吐反应严重，不能长途坐车，加上新房子装修完也晾了大半年了，索性就把爸妈们都接到苏州来过年了。年后依旧是忙碌的工作和生活，老婆的肚子也一天天大了起来，骑电驴上班不方便了，于是每天先把老婆送去单位，我再去上班，那段时间几乎天天迟到。7 月底，儿子顺利出生，比预产期提前了，我打了鸡血一样的在医院陪了三天三夜。其实老婆刚怀孕的时候，我挺希望是个女儿的，不过儿子一出生这种想法竟然就消失了，现在每天下班回到家看到他那萌萌的笑，再苦再累都值得。产后给老婆报名了 C2 驾照，她很努力，在产假结束时顺利拿到驾照，不得不说，真的厉害。至于为什么考 C2 而不是 C1，其实就是为了合法上路开个车，当然怎么简单怎么来，何苦为难自己呢，不过身边还是有很多人 C2 驾照有所偏见。 说完生活再谈工作，年初公司组织架构又特么变动了，原通用架构组解散，人员分流到各产品组。我毫无悬念的加入到一个完全不熟悉的产品组。除了负责原先 Android 端的项目外，我花了一周的时间来学习 WPF 相关知识，于是很快就投入到了新团队的工作中，不得不说，WPF 和 Android 开发真的有很多异曲同工之处，上手并不难，当然深入学习还是一个漫长的积累过程。年中，小组产品转型，需要开发配套移动端 App，组里讨论后一致采用 Web App + 壳子的形式，方便后期维护升级。然而组里就我一个移动端开发，任务自然落到了我头上，令人欣慰的是，在组里一位前端大神的带领下我又开启了前端学习之路。没过多久，大神因为项目需要调去了其他产品组，后来这个项目也慢慢没什么新需求了。后来我还用学了半吊子的前端撸了个简易 App 管理平台，发给一个项目现场试用，反馈竟然很好。 今年除了学习 WPF 和前端开发，Android 老本行也不能落下。这一年陆陆续续读完了《Kotlin in Action》、《Kotlin 核心编程》以及极客时间上看了一大半的《快速上手 Kotlin 开发》视频课，对于 Kotlin 有了较好的学习，再加上这两年 Google 大力推荐的 Jetpack 组件，利用业余时间开发了一款公交 App，新语言+新组件，一个字总结：真香！这个项目暂时没开源，目前 App 仅有一位用户，他为这款应用提供了很多有意思的想法，他对于最后的成品也给与了很高的评价。同时我正也因为这个 App 的试水，后来公司好几个新产品的开发都切换到 Kotlin + Jetpack。 今年 9 月 10 日，第一次去上海参加 Google Developer Days 2019，体验了 Google 前沿科技，了解技术发展方向。下午听了几场 Android 相关的专题演讲，最后拿到了传说中的信仰背包，物质和精神得到了极大的满足，嘿嘿。 今年尝试加入了几个付费知识星球，发现内容真是良莠不齐，圈钱动机明显。唯一值得加入的竟然是仅 64 元的 Drakeets Pro，虽然更新频率不是很高，但星主的分享无论从专业性以及独特性都是分分钟值回票价的，不过很可惜，由于种种原因，星主不打算继续运营下去，挺遗憾的。 自从儿子出生，手机相册容量频频告急，加上那段时间大批矿难，咸鱼上好多便宜的蜗牛星际主机，拿来折腾黑群晖再好不过了。拿到机器更换了吵人的风扇以及速度慢如蜗牛的 SSD，问电信要了公网 IP 配合 DDNS，目前已稳定运行快半年了。日常就拿来存存照片，下下片子，跑个 docker，整个 frp 啥的，可玩性还是相当高的。 双十一，媳妇突然送我 AirPods，她说看它躺在我购物车大半年了，怪可怜的。这一个半月的体验下来，简直太棒了，我太喜欢这无拘无束的感觉了，对于我这种木耳朵音质也是相当满意的，好评耶~ 2019 收获满满，2020 整装待发。 最后希望未来一切安好，努力赚钱养家，这才是最好的 Flag。 ","link":"https://liyuyu.cn/post/my-2019/"},{"title":"RecyclerView 指定 Item 滚动居中显示","content":"这是一个老生常谈的话题了。 RecyclerView 提供了两个方法 scrollToPosition(position) 和 smoothScrollToPosition(position) 来将指定的 item 滚动到屏幕中，但不会居中显示，且在滚动到同一 position 的条件下，两个方法的最终效果也是不一样的（废话，方法名都不一样）。 其实我们距离成功只差半个屏幕了，与其从头开始实现，不如分析下上面两个方法，也许会带来事半功倍的效果。 1. scrollToPosition(position) 通过源码发现，在调用 recyclerView.scrollToPosition(position) 其实调用的是 layoutManager.scrollToPosition(position) 方法，下面是 LinearLayoutManager 对应的代码： @Override public void scrollToPosition(int position) { //当 LayoutManager 需要滚动到某个位置时，设置 mPendingScrollPosition 为目标位置，进行重新布局时将检查此变量。 mPendingScrollPosition = position; // 当调用 scrollToPositionWithOffset 方法时才使用到，这里不解释 mPendingScrollPositionOffset = INVALID_OFFSET; if (mPendingSavedState != null) { // 重置锚点 mPendingSavedState.invalidateAnchor(); } // 请求重新布局 requestLayout(); } 顺藤摸瓜，接着调用 mRecyclerView.requestLayout()，触发 RecyclerView#onLayout 方法，在 onLayout 方法里调用 dispatchLayout() =&gt; dispatchLayoutStep2() 最后调用 mLayout.onLayoutChildren(mRecycler, mState)，又回到了 LinearLayoutManager 里： @Override public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) { // 布局算法主要分为 4 步： // 1. 检查 Children 和其他变量，找到锚点信息，计算更新保存绘制锚点信息 // 2. 在锚点位置朝 start 方向上填充 ItemView // 3. 在锚点位置朝 end 方向填充 ItemView // 4. 滚动以满足从底部堆栈的要求。 ... if (!mAnchorInfo.mValid || mPendingScrollPosition != RecyclerView.NO_POSITION || mPendingSavedState != null) { mAnchorInfo.reset(); // 锚点重置 mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd; // 布局方向，mStackFromEnd 默认为 false // 重点来了：开始更新锚点信息！如果我们设置了有效的 mPendingScrollPosition // 接下来将会在 updateAnchorFromPendingData(state, anchorInfo) 方法中将 anchorInfo.mPosition = mPendingScrollPosition; // 这样就把锚点设置为了我们想要显示的目标位置了 updateAnchorInfoForLayout(recycler, state, mAnchorInfo); mAnchorInfo.mValid = true; } ... // 后面就会按照锚点位置以及布局方向等信息开始布局绘制，以及各种滚动偏移量，这里不做过多的赘述 } 简单概括下 scrollToPosition(position) 的实现过程就是：把锚点设置为需要显示的目标位置，然后请求 RecyclerView 重新布局。这一过程看似简单，实则很复杂，且最终效果也不是我们想要的滚动居中的动态效果。 2. smoothScrollToPosition(position) 从名字就可以看出，这一过程是平滑的，还是接着扒源码，在调用 recyclerView.smoothScrollToPosition(position) 其实调用的是 layoutManager.smoothScrollToPosition(position) 方法，最终调用具体 LayoutManager 的 smoothScrollToPosition(RecyclerView recyclerView, State state, int position) 方法，下面是 LinearLayoutManager 对应的代码： @Override public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, int position) { // 创建一个线性平滑滚动器 LinearSmoothScroller linearSmoothScroller = new LinearSmoothScroller(recyclerView.getContext()); // 设置滚动器目标位置 linearSmoothScroller.setTargetPosition(position); // 开始平滑滚动（如果目标位置不在屏幕范围内，则一直匀速滚动，一旦目标位置出现在屏幕上就减速滑动直至停止） startSmoothScroll(linearSmoothScroller); } 三行代码，简单粗暴，接下来分析下滚动器是如何发现目标位置的。先从 LinearSmoothScroller 的基类 SmoothScroller 入手: 2.1 SmoothScroller 是如何实现不断滚动的？ 如果目标位置不在当前屏幕范围内，我们是无法获取到对应的 itemView 的，所以第一步就是让 RecyclerView 滚动起来。 调用 SmoothScroller#start 方法开始滚动，如下： void start(RecyclerView recyclerView, LayoutManager layoutManager) { ... // 开始滚动标记 mRunning = true; ... //这里使用 ViewFlinger 进行滚动动画，ViewFlinger 实现了 Runnable 接口，并且内部使用了 OverScroller mRecyclerView.mViewFlinger.postOnAnimation(); ... } ViewFlinger 实现如下： private class ViewFlinger implements Runnable { @Override public void run() { ... // 判断 scroller 滚动是否完成， true 为滚动未完成 if (scroller.computeScrollOffset()) { ... //调用 SmoothScroller 的 onAnimation 方法，此方法将在下面详细分析 smoothScroller.onAnimation(dx - overscrollX, dy - overscrollY); ... } } } 其实滚动的核心是不停地调用 ViewCompat.postOnAnimation(RecyclerView.this, action); 来实现动画效果。 2.2 SmoothScroller 是如何找到目标位置的？ 还是以 LinearLayoutManager 为例，布局的核心流程都在 onLayoutChildren 方法里，一路追踪下去 onLayoutChildren =&gt; fill =&gt; layoutChunk =&gt; addDisappearingView =&gt; addViewInt =&gt; mSmoothScroller.onChildAttachedToWindow(child); 最终调用 SmoothScroller#onChildAttachedToWindow 方法如下： protected void onChildAttachedToWindow(View child) { // 每个 child 被“滚动”到屏幕上时都会调用该方法，判断下 child 的 position 是否等于目标位置即可 if (getChildPosition(child) == getTargetPosition()) { // 找到我们要的 itemView 啦~ mTargetView = child; ... } } 前面提到过，在滚动的过程中，ViewFlinger 会不断调用 smoothScroller.onAnimation 方法，那么只要在这个方法里判断 mTargetView 是否为 null 就可以了： private void onAnimation(int dx, int dy) { ... if (mTargetView != null) { // 再次核对下 if (getChildPosition(mTargetView) == mTargetPosition) { // 最终回调 onTargetFound 方法 onTargetFound(mTargetView, recyclerView.mState, mRecyclingAction); ... } ... } ... } 值得注意的是，当 onTargetFound 方法被调用时，mTargetView 并不一定被完整的显示出来，可能只&quot;露出了一丢丢身子&quot;，也有可能已经完整出现在屏幕上了。 2.3 如何矫正目标 TargetView ？ onTargetFound 是抽象方法，来看下 LinearLayoutManager 具体是怎么实现 mTargetView 位置&quot;矫正&quot;的： public class LinearSmoothScroller extends RecyclerView.SmoothScroller { @Override protected void onTargetFound(View targetView, RecyclerView.State state, Action action) { // 计算矫正 targetView 需要再移动的水平距离 // getHorizontalSnapPreference() 此方法定义是否将 targetView 的左边缘或右边缘与父 RecyclerView 对齐。 final int dx = calculateDxToMakeVisible(targetView, getHorizontalSnapPreference()); // 计算矫正 targetView 需要再移动的垂直距离 // getVerticalSnapPreference() 此方法定义是否将 targetView 的上边缘或下边缘与父 RecyclerView 对齐。 final int dy = calculateDyToMakeVisible(targetView, getVerticalSnapPreference()); // 计算原始位置和最终位置的距离 final int distance = (int) Math.sqrt(dx * dx + dy * dy); // 根据距离评估下动画时间 final int time = calculateTimeForDeceleration(distance); if (time &gt; 0) { //向最终位置发起减速运动，最终让 targetView 矫正在指定位置 action.update(-dx, -dy, time, mDecelerateInterpolator); } } ··· } 其实到了这里，问题就变得很简单了，要实现“居中”效果，只要在 onTargetFound 方法里做文章就可以了，依葫芦画瓢。 3. 动手实现 scrollToCenter 效果 在此之前，不得不提下 RecyclerView 在 24.2.0 版本中新增的 SnapHelper 这个类，它用于辅助 RecyclerView 在滚动结束时将 Item 对齐到某个位置。由于是一个抽象类，官方又提供了一个 LinearSnapHelper 的子类，可以在 RecyclerView 滚动停止时将相应的 Item 停留中间位置，LinearSnapHelper 的效果已经非常接近我们的目标了，只不过 LinearSnapHelper 需要用户主动滑动，且仅仅是滚动停止时把距离中心最近的 Item 居中了。不过可以借鉴其实现思路结合 LinearSmoothScroller 实现我们的目标效果。 自定义 MyLinearSmoothScroller 实现自动滚动并居中的效果，完整代码如下： class MyLinearSmoothScroller(context: Context) : LinearSmoothScroller(context) { override fun onTargetFound(targetView: View, state: RecyclerView.State, action: Action) { // 计算距离 val distance = distanceToCenter( layoutManager!!, targetView, getOrientationHelper(layoutManager!!)!! ) // 计算动画时间 val time = calculateTimeForDeceleration(distance) if (time &gt; 0) { // 这里仅实现了水平或者垂直一种方向上的矫正，两者同时的情况暂不考虑 if (layoutManager!!.canScrollVertically()) action.update(0, distance, time, mDecelerateInterpolator) else action.update(distance, 0, time, mDecelerateInterpolator) } } /** * 计算 targetView 中心点到 RecyclerView 中心点的距离 */ private fun distanceToCenter( layoutManager: RecyclerView.LayoutManager, targetView: View, helper: OrientationHelper ): Int { val childCenter = helper.getDecoratedStart(targetView) + helper.getDecoratedMeasurement(targetView) / 2 val containerCenter = if (layoutManager.clipToPadding) { helper.startAfterPadding + helper.totalSpace / 2 } else { helper.end / 2 } return childCenter - containerCenter } /** * 不同方向上的距离使用不同的 OrientationHelper */ private fun getOrientationHelper(layoutManager: RecyclerView.LayoutManager): OrientationHelper? { if (layoutManager.canScrollVertically()) { return OrientationHelper.createVerticalHelper(layoutManager) } else if (layoutManager.canScrollHorizontally()) { return OrientationHelper.createHorizontalHelper(layoutManager) } return null } } 调用： val scroller = MyLinearSmoothScroller(recyclerView.context) //设置目标位置 scroller.targetPosition = 10 //开始平滑滚动 recyclerView.layoutManager!!.startSmoothScroll(scroller) 效果图如下： 4. 总结 扒了一篇源码，果然受益匪浅 ","link":"https://liyuyu.cn/post/RecyclerViewScrollToCenter/"},{"title":"我的 2018","content":"年纪越大，感觉时间过得越快，要不是翻看手机相册，都不知道这一年是怎么过的。 今年印象深刻的几件事 年初苏城的一场大雪，上次经历这么大的雪好像还是 2008 高三那一年，一晃 10 年了哟。 4 月部门团建去了浙江开化，欣赏了一望无际的油菜花，也吃到了当地特色名菜清水鱼，舟车劳顿，晚上约了个同事去捏脚，第二天爬山轻轻松松。 今年和几个朋友组织了几次野钓，收获满满，乐趣无穷。 因公司项目研发需要，年中的时候去郑州出差了两次，完整体验了 120 急救流程，看到了危急的心脏病患者，也看到了溺水奄奄一息的少女，不禁感慨生命的可贵。 今年加了一次薪，虽然不多，但遇到了一帮靠谱的队友，团队协作，轻松高效。有的时候，钱固然重要，但干得开心也很重要。 最后，今年最最激动和开心的就是老婆圣诞节送我的大礼了，哈哈哈！ 今年看过的书以及付费阅读 今年也买了好几本书，但遗憾的是并没有全部看完，除了公司项目繁忙和自己的懒惰外，也找不到其他理由了。不过好在，我把更多的碎片时间留给了网络学习。 《Android 开发艺术探索》 多年之后，再次阅读，依然收获很大。 《图解 HTTP》 书不厚，几天就翻完了，填鸭式阅读，很多东西还要深入理解。 《Java 核心技术 36 讲》 Java 重点知识的复习与加深。 《Android 开发高手课》 追更中，日常补漏学习。 今年看过的电影 头号玩家 游戏爱好者表示大呼过瘾！ 复仇者联盟3：无限战争 漫威宇宙超级英雄集合，结尾无限惆怅，期待下集！ 我是药神 现实的缩影，感人肺腑，最后落泪了。 蚁人 2：黄蜂女现身 轻松有趣，亮点不多，衔接《复联3》结尾，令人遐想。 毒液：致命守护者 暗黑风混搭爆米花，基情四射，特效值回票价。 西虹市首富 抛去所有笑点，仍然回味无穷。 僵尸先生 僵尸片的祖师爷，30 多年过去了，依旧好看。 机器人总动员 看了不知多少遍了，每次都被瓦力感动到哭，被媳妇笑惨了。 摩天营救 强森出演，烂片一部！ 幕后玩家 能猜得到剧情的悬疑片，有亮点也有槽点。 电锯惊魂 8 ：竖锯 熟悉的老套路，也就不觉得那么惊艳了。 外星人E.T. 自行车腾空而起的画面，记忆一下子燃了起来。 明日边缘 一个关于游戏存档，最后通关的故事，几年前在院线看的时候还是觉得挺有意思的。 一出好戏 荒岛求生，人性考验。 为了给媳妇补课《复联 3》再次看了美国队长、雷神、钢铁侠、无敌浩克、蚁人以及奇异博士等全系列电影。 最后，FLAG 还是要立的 去年年终总结的时候计划学习下 Python 和 Web 前端开发，很遗憾，一年过去了，仅安装了开发环境，学习了一些基础知识外，便停止了。我真的害怕立 FLAG 了，『间歇性踌躇满志 持续性混吃等死』是最真实的写照了。 虽然 2018 年新技术涉猎的不多，但好在 Android 老本行还是查漏补缺了不少，在接下来的一年，计划完成极客时间 App 里的《数据结构与算法之美》、《趣谈网络协议》以及《快速上手 Kotlin 开发》三个付费专栏的学习，毕竟花钱了嘛。 最后希望未来一切安好，努力赚钱养家。 ","link":"https://liyuyu.cn/post/My2018/"},{"title":"使用 WebSocket 实现 JsBridge","content":"去年写了个简单的 Android 壳子程序在部门内部使用，借助壳子程序 JavaScript （以下简称 JS）可以高效地使用拍照、签名、二维码扫描等原生功能，为 Web 项目提供接近原生的体验。 但是一段时间使用下来，前端开发人员陆陆续续地反馈了一些蛋疼的问题，比如正常情况下可以使用 Chrome 浏览器的 chrome://inspect 功能调试设备上的远程网页，但是一些设备死活都无法 inspect，这给开发调试带来了很多不便，而后我在思考，还有没有另一种方式既能实现基本的 JsBridge 功能又能方便开发人员调试。 我想到了 WebSocket，它是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。不过，在具体介绍 Websocket 之前先简单回顾下目前主流 JsBridge 的实现方案。 1. addJavascriptInterface 方式 这是 Android 官方推荐的交互方式，但是在 Android 4.2 以下存在安全漏洞，后期官方通过在 Java 远程方法上添加注解 @JavascriptInterface 解决了这一安全隐患。 1.1 Java 调用 JS 方法 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) { webView.evaluateJavascript(script, new ValueCallback&lt;String&gt;() { @Override public void onReceiveValue(String value) { // 处理 JavaScript 方法的返回值 } }); } else { webView.loadUrl(&quot;javascript:&quot; + script);// 低版本通用方式，但有弊端：无法获取返回值 } 1.2 JS 调用 Java 方法 Java 端注入接口等待调用： class BridgeInterface { @JavascriptInterface public String call(String msg) { return &quot;Hello!&quot;; } } ... webView.addJavascriptInterface(new BridgeInterface(), &quot;JsBridge&quot;); JS 端调用： if(window.JsBridge){ JsBridge.call(msg); } 2. onJsPrompt 方式 为解决 Android 4.2 以下安全漏洞，肯定不能再使用 addJavascriptInterface 方式了，我们可以使用 HTML DOM prompt() 方法配合 WebChromeClient 的 onJsPrompt 回调方法实现交互。 Java 端等待回调： @Override public boolean onJsPrompt(WebView view, String url, final String message, String defaultValue, final JsPromptResult result) { // message 和 defaultValue 为 JavaScript 端传来参数 // 我们还可以通过 JsPromptResult 返回数据给 JavaScript 端，例如：result.confirm(&quot;Done!&quot;); } JS 端调用： prompt(message, defaultValue); 3. 拦截 Url 方式 https://github.com/lzyzsd/JsBridge 提供了一个很好的思路，通过 shouldOverrideUrlLoading 来拦截指定规则的 Url，然后处理业务逻辑实现两端交互。 由于 Java 调用 JS 方法都大同小异，这里我们不做过多的说明。 页面加载完成后，JsBridge 动态创建了一个不可见的 iframe，在需要通知 Java 端时在 JS 消息队列里添加新的消息，同时改变 iframe 的 src 值触发 WebView 的 shouldOverrideUrlLoading 回调方法，然后 Java 端调用 javascript:WebViewJavascriptBridge._fetchQueue(); 方法准备获取数据，调用后触发 iframe 的 src 值改变，此时 src 值为需要传递给 Java 端的数据，最后再次触发 shouldOverrideUrlLoading 回调方法，Java 端解析 url 取出数据，完成整个调用流程。 整个流程稍显啰嗦了一点，JS 端发消息给 Java 端完全可以把两步合并为一步，此外通过改变 iframe src 属性的这种方式并不能保证 shouldOverrideUrlLoading 每次都会被调用。 4. WebSocket 方式 在使用之前，我对 WebSocket 并不熟悉，网上找不到使用它来实现 JsBridge 的相关资料，不过这并不能阻止我尝试的脚步。 WebSocket 协议在 2008年 诞生，2011 年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 其特点包括： 建立在 TCP 协议之上，服务器端的实现比较容易。 与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 数据格式比较轻量，性能开销小，通信高效。 可以发送文本，也可以发送二进制数据。 没有同源限制，客户端可以与任意服务器通信。 协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL。 WebSocket 的相关特性刚好满足 Native 端和 JS 端交互。 4.1 搭建 Android 端 WebSocket 服务器 这里用的是开源项目 AndroidAsync 搭建服务器，示例代码如下： AsyncHttpServer server = new AsyncHttpServer(); List&lt;WebSocket&gt; _sockets = new ArrayList&lt;WebSocket&gt;(); server.websocket(&quot;/live&quot;, new WebSocketRequestCallback() { @Override public void onConnected(final WebSocket webSocket, AsyncHttpServerRequest request) { _sockets.add(webSocket); //连接断开时的回调 webSocket.setClosedCallback(new CompletedCallback() { @Override public void onCompleted(Exception ex) { try { if (ex != null) Log.e(&quot;WebSocket&quot;, &quot;Error&quot;); } finally { _sockets.remove(webSocket); } } }); // 我们可以在这里处理来自 JS 端的消息 webSocket.setStringCallback(new StringCallback() { @Override public void onStringAvailable(String s) { if (&quot;Hello Server&quot;.equals(s)) webSocket.send(&quot;Welcome Client!&quot;);// Java 端发消息给 JS 端 } }); } }); server.listen(5000); 4.2 JS 实现 WebSocket 客户端 // 创建完对象后，客户端就会与服务器进行连接 var ws = new WebSocket(&quot;wss://localhost:5000/live&quot;); ws.onopen = function(evt) { // 连接成功后 console.log(&quot;Connection open ...&quot;); }; ws.onmessage = function(evt) { // 收到服务端的消息 console.log( &quot;Received Message: &quot; + evt.data); }; ws.onclose = function(evt) { // 连接断开后 console.log(&quot;Connection closed.&quot;); }; ... // JS 端发消息给服务端 ws.send(&quot;Hello Server&quot;); 写了个测试 Demo，发现整体效果还是可以的，后期完善下可以独立出来做个开源组件了。 总结 WebSocket 并不是新鲜技术，用它来实现 JsBridge 也有点杀鸡用牛刀的错觉，但也不失为一种新的思路。此外，通过这种方式我们可以不使用 chrome://inspect 来调试远程网页了，把 JS 里 localhost 改为手机的 IP 地址就可以实现在任意电脑上调试 JsBridge了。 注意，原生 WebView 在 Android 4.4.x (KitKat) 之后才支持 WebSocket，如果想兼容低版本可以尝试使用一些第三方 WebView 组件，例如腾讯浏览服务 TBS。 参考 Android WebView 的 Js 对象注入漏洞解决方案 JsBridge 使用和原理 JsBridge WebViewJavascriptBridge WebSocket 教程 ","link":"https://liyuyu.cn/post/WebSocketJsBridge/"},{"title":"回顾几个 Java 关键字","content":"温故而知新，却还是那一套。 static 关键字 static 方法：一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问。但是要注意的是，虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。 static 变量：也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。 static 代码块：用来形成静态代码块以优化程序性能。在类初次被加载的时候，会按照 static 块的顺序来执行每个 static 块，并且只会执行一次。 static 内部类：如果一个类要被声明为 static 的，只有一种情况，就是静态内部类。静态内部类使用场景一般是当外部类需要使用内部类，而内部类无需外部类资源，并且内部类可以单独创建的时候会考虑采用静态内部类的设计。 典型应用场景：如果类的构造器或静态工厂中有多个参数，设计这样类时，最好使用 Builder 模式，特别是当大多数参数都是可选的时候，例如 Android 里的 AlertDialog： AlertDialog.Builder builder = new AlertDialog.Builder(this).setTitle(&quot;标题&quot;).setMessage(&quot;你好呀&quot;).create(); final 关键字 final 类：当用 final 修饰一个类时，表明这个类不能被继承，final 类中的所有成员方法都会被隐式地指定为 final 方法。 final 方法：如果想禁止该方法在子类中被覆盖，可以将方法设置为 final，此外类的 private 方法会隐式地被指定为 final 方法。 final 变量：对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 synchronized 关键字 修饰代码块：被修饰的代码块称为同步语句块，其作用的范围是大括号 {}括起来的代码，作用的对象是调用这个代码块的对象。 一个线程访问一个对象中的 synchronized(this) 同步代码块时，其他试图访问该代码块的线程将被阻塞。 当一个线程访问对象的一个 synchronized(this) 同步代码块时，另一个线程仍然可以访问该对象中的非 synchronized(this) 同步代码块。 当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的对象来充当锁： private byte[] lock = new byte[0]; synchronized(lock) { // todo 同步代码块 } 修饰普通方法：synchronized 修饰方法和修饰一个代码块类似，只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。 synchronized 关键字不能继承。 在定义接口方法时不能使用 synchronized 关键字。 构造方法不能使用 synchronized 关键字，但可以使用 synchronized 代码块来进行同步。 修饰静态方法：由于静态方法是属于类的而不属于对象的所以 synchronized 修饰的静态方法锁定的是这个类的所有对象。 修饰一个类：synchronized 作用于一个类 T 时，是给这个类 T 加锁，T 的所有对象用的是同一把锁。 synchronized(ClassName.class) { // todo 同步代码块 } volatile 关键字 volatile，字面意思是易变的，不稳定的， 一般用于修饰变量。 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。 volatile 关键字在某些情况下性能要优于 synchronized，但是要注意 volatile 关键字是无法替代 synchronized 关键字的，因为 volatile 关键字无法保证操作的原子性。 assert 关键字 assert，字面意思是声称，断言，有两种用法： assert &lt;boolean 表达式&gt; 如果表达式为 true，则程序继续执行。 如果为 false，则程序抛出 AssertionError，并终止执行。 assert &lt;boolean 表达式&gt; : &lt;错误信息表达式&gt; 如果表达式为 true，则程序继续执行。 如果为 false，则程序抛出 java.lang.AssertionError，并输出&lt;错误信息表达式&gt;。 在 Android 开发中除非在 debug 模式下，否则 assert 根本无法工作，所以不太建议在生产环境下使用 assert，此外主流的 Java IDE 工具默认都没有开启断言检查功能。 Android Studio 或者 IDEA 开启 assert 的方式：Tools -&gt; Edit Configurations -&gt; VM options, 输入 -enableassertions 或者 -ea 保存即可。 Android 设备开启 assert 检查可以使用以下命令：adb shell setprop debug.assert 1 ","link":"https://liyuyu.cn/post/JavaKeywords/"},{"title":"使用 ViewDragHelper 实现图片下拽返回","content":"微信的图片下拽返回功能在日常使用中非常方便，同时在很多 App 中都见到了类似的设计，可以说一旦习惯这种操作再也回不去了。 这几天逛 GitHub，发现一个很赞的库 https://github.com/iielse/ImageWatcher 高度还原了微信的效果，粗看了下源码，我觉得可以更简单的实现类似的效果，动手实现后，发现 ViewDragHelper + ActvitySceneTransition 的方案简单粗暴。 什么是 ViewDragHelper 具体实现之前先简单介绍下什么是 ViewDragHelper。 ViewDragHelper 是 support v4 兼容包中的一个工具类，用来简化自定义 ViewGroup 中的手势处理。 使用 ViewDragHelper 可以轻松实现 ViewGroup 里 View 的拖拽操作，这里介绍下使用 ViewDragHelper 里几个重要步骤。 初始化 通过静态方法创建：viewGroup 即为当前容器；sensitivity 为拖拽的灵敏度，默认为 1；callback 为配置拖拽中的各种逻辑处理。 mViewDragHelper = ViewDragHelper.create(viewGroup, callback); ... or ... mViewDragHelper = ViewDragHelper.create(viewGroup, sensitivity, callback); Callback 这里仅列出我们需要使用到的一些回调方法： public abstract static class Callback { /** * 当子 View 被拖动改变位置时回调此方法 * * @param changedView 当前子 View * @param left 当前子 View 的最新 X 坐标 * @param top 当前子 View 的最新 Y 坐标 * @param dx 当前子 View 的最新 X 坐标较上次 X 的位移量 * @param dy 当前子 View 的最新 Y 坐标较上次 Y 的位移量 */ public void onViewPositionChanged(@NonNull View changedView, int left, int top, int dx, int dy) { } /** * 当子 View 被释放后回调此方法 * * @param releasedChild 当前子 View * @param xvel X 子 View 被释放时，用户手指在屏幕上滑动的横向加速度 * @param yvel Y 子 View 被释放时，用户手指在屏幕上滑动的纵向加速度 */ public void onViewReleased(@NonNull View releasedChild, float xvel, float yvel) {} /** * 限制子 View 水平拖拽范围。 * * 如果返回 0，则不能进行水平拖动，如果要实现拖拽，返回值 &gt; 0 即可。 * */ public int getViewHorizontalDragRange(@NonNull View child) { return 1; } /** * 限制子 View 纵向拖拽范围。 * * 如果返回 0，则不能进行纵向拖动， 我们要实现拖拽，返回值 &gt; 0 即可。 * */ public int getViewVerticalDragRange(@NonNull View child) { return 1; } /** * 判断当前触摸的 View 能否被捕获进行拖拽，如果返回 true 则可以进行拖拽。 */ public abstract boolean tryCaptureView(@NonNull View child, int pointerId); /** * 限制当前 View 的横向拖拽范围，也可说是我们可以动态修正 View 的 top 坐标，比如我们想限制 View 只在容器内部拖动 * * @param child 当前拖动的 View * @param left View 上次的 x 坐标 + 手指移动的 x 轴位移量 * @param dx 手指移动的位移量 * @return 修正后的 x 坐标，直接返回 left 表示不限制水平拖拽范围，拖到哪儿就哪儿 */ public int clampViewPositionHorizontal(@NonNull View child, int left, int dx) { return left; } /** * 限制当前 View 的纵向拖拽范围，也可说是我们可以动态修正 View 的 top 坐标，比如我们想限制 View 只在容器内部拖动 * * @param child 当前拖动的 View * @param top View 上次的 y 坐标 + 手指移动的 y 轴位移量 * @param dx 手指移动的位移量 * @return 修正后的 x 坐标，直接返回 top 表示不限制纵向拖拽范围，拖到哪儿就哪儿 */ public int clampViewPositionVertical(@NonNull View child, int top, int dy) { return top; } } 处理 Touch 事件 复杂的触摸逻辑就让 ViewDragHelper 接管即可。 @Override public boolean onInterceptTouchEvent(MotionEvent ev) { return mViewDragHelper.shouldInterceptTouchEvent(ev); } @Override public boolean onTouchEvent(MotionEvent event) { mViewDragHelper.processTouchEvent(event); return true; } 处理 View 自动复位效果 当拖拽操作不满足触发条件时，手指松开，View 需要自动回到初始位置，在 onViewReleased 里调用以下方法即可： mViewDragHelper.settleCapturedViewAt(originPoint.x, originPoint.y); invalidate(); 同时需要覆写： @Override public void computeScroll() { if (mViewDragHelper.continueSettling(true)) { ViewCompat.postInvalidateOnAnimation(this); } } 具体实现步骤 1. 自定义 DragLayout，内部使用 ViewDragHelper 来处理拖拽操作。 2. 创建 Activity 展示图片，使用 DragLayout 作为根布局: &lt;com.liyu.fakeweather.widgets.DragLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/drag_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/black&quot; android:fitsSystemWindows=&quot;true&quot;&gt; &lt;ImageView android:id=&quot;@+id/picture&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_centerInParent=&quot;true&quot; android:adjustViewBounds=&quot;true&quot; android:scaleType=&quot;fitCenter&quot; /&gt; &lt;/com.liyu.fakeweather.widgets.DragLayout&gt; 并设置 Activity 背景为透明： activity.getWindow().getDecorView().setBackgroundColor(Color.TRANSPARENT);// 当然也可以在 theme 里设置 3. 实现拖拽时动态改变背景透明度以及图片的缩放效果： @Override public void onViewPositionChanged(@NonNull View changedView, int left, int top, int dx, int dy) { if (top &gt; originPoint.y) {// 仅当向下拖拽时才处理 float a = (float) (top - originPoint.y) / (float) (getMeasuredHeight() - originPoint.y); setBackgroundColor(ThemeUtil.changeAlpha(0xff000000, 1 - a));// 根据拖拽位移量动态改变背景透明度 targetView.setScaleX(1 - a);// 缩放图片 targetView.setScaleY(1 - a);// 缩放图片 if ((top - originPoint.y) &gt; getMeasuredHeight() / 5) { callEvent = true; // 下拽的位移量满足要求，可以触发关闭操作 } else { callEvent = false;// 不能触发关闭操作 } } } 4. 手指释放时逻辑处理： @Override public void onViewReleased(@NonNull View releasedChild, float xvel, float yvel) { if (releasedChild == targetView) { if (callEvent || yvel &gt; 8000) {// 除了判断下拽的位移量，还要判断快速下拽的速度，这边 yevl 为用户手指快速滑动的 Y 轴加速度，当加速度大于一定值时也可触发关闭操作 if (listener != null) { listener.onDragFinished(); } callEvent = false; } else { // 当拖拽不满足触发条件时，需要将 View 归位，这里使用自带的方法实现动画效果，传入初始坐标即可。 mViewDragHelper.settleCapturedViewAt(originPoint.x, originPoint.y); invalidate(); } } } 5. 图片的转场动画： 使用自带转场动画即可实现图片的打开和关闭动画。 ActivityOptionsCompat optionsCompat = ActivityOptionsCompat.makeSceneTransitionAnimation( (Activity) context, transitView, PictureActivity.TRANSIT_PIC); ActivityCompat.startActivity(context, intent, optionsCompat.toBundle()); ... ViewCompat.setTransitionName(mImageView, TRANSIT_PIC); ... 图片下拽返回的功能加入到了假装看天气的妹子图模块中，完整示例代码可前往 https://github.com/li-yu/FakeWeather/blob/master/app/src/main/java/com/liyu/fakeweather/widgets/DragLayout.java 查看。 总结 依靠简单而又强大的 ViewDragHelper，不到 200 行的代码也实现了类似的效果。他山之石可以攻玉，翻看其源码，也学到一些很少用到的小技巧，比如获取当前触摸位置的子 View，逆向遍历全部子 View 集合然后判断触摸坐标是否在范围内，真是简单粗暴： @Nullable public View findTopChildUnder(int x, int y) { final int childCount = mParentView.getChildCount(); for (int i = childCount - 1; i &gt;= 0; i--) { final View child = mParentView.getChildAt(mCallback.getOrderedChildIndex(i)); if (x &gt;= child.getLeft() &amp;&amp; x &lt; child.getRight() &amp;&amp; y &gt;= child.getTop() &amp;&amp; y &lt; child.getBottom()) { return child; } } return null; } ","link":"https://liyuyu.cn/post/Dragback/"},{"title":"我的 2017","content":" 与往年不同，这一年生活成了我的全部。 生活 年初和媳妇领完证，拍婚纱照，办酒席，两个人累得跟狗一样。蜜月目的地选在了巴厘岛，传说中明星结婚的圣地。第一次出国门，我们显得很是期待和兴奋，为了保证旅行质量，我们报了途牛的“精致 VIP 小团”，事后证明，所谓的“精致”都是忽悠，和平常的跟团没啥区别，下一次再去巴厘岛，我选自由行。 作为一个程序员，做饭这门手艺简直就是一种天赋，这一年，媳妇说我比她妈做的好吃，哈。目前最拿手的几道菜是：土豆回锅肉片、清蒸鲈鱼、鲫鱼豆腐汤、油焖大虾。六月份买了电烤箱，学会了做戚风蛋糕和蛋挞，然而面包和吐司在失败了 N 次后，现已放弃。 『会做饭的人，可能也是个吃货』，我不记得谁说的这句话，反正挺有道理的，结婚前 65 kg 的我，现在 73 kg。 意识到体重的飙升，媳妇开始监督我锻炼，跑步、跳绳、打球、举铁，目前已坚持 2 个月了，不过目前气温骤降，加上雾霾天气，户外跑步已停止，等待明年春天继续。 长期久坐，缺乏锻炼导致程序员的体质普遍不好。这 2 个月的锻炼，虽然体质没有明显提升，但是我发现即使不午睡，下午敲代码也不困了。 工作 年初，公司组织变动，加入了通用架构组，负责 Android 端通用框架开发维护以及新技术学习研究。这一年，除了 Java 和 Android，还学习了 ASP.NET MVC、Spring Boot 等后端技术，以及 Oracle 数据库，总体来讲，收获很多。 七月份，公司给每位员工发了一本《四书》，每天早晨 20 分钟，花了五个月的时间，读完了这本书，发现根本没学到什么。『我们听过无数的道理，却仍旧过不好这一生』应该是最真实的写照。 这一年，踏实敬业，应该算是个好员工吧。 明年计划学习下 Python 和 Web 前端开发。 最后希望未来一切安好，努力赚钱养家。 ","link":"https://liyuyu.cn/post/My2017/"},{"title":"重构天气","content":" 时间过得很快，《假装看天气》这个小项目诞生已经有一年了，因为是练手项目，写完之后也没过多的维护，直到有一次在站酷上看到一个天气设计原型，我被她简洁又漂亮的 UI 惊艳到，进而有了重构天气模块的念头。 理想是丰满的，现实总是残酷的。 站酷上的原型只有图片展示，并没有提供原始设计档下载，所以我只能“抄”图片了。由于没有 Mac 设备，自然用不了神器 Sketch，又畏惧于功能强大但复杂的 PS 和 AI，最后我选择了 Figma，一个基于浏览器的 UI 设计工具，上手简单，功能强大。 陆陆续续的花了几个晚上完成了天气场景中背景图片的绘制： 虽然完成的不够精细，但对于一个不懂设计的程序猿，我还挺满意。 万事俱备，只差 coding，正好这段时间在看扔物线的《给高级 Android 工程师的进阶手册》，收获颇多，拿天气模块开刀简直再合适不过了。 重构天气模块主要涉及以下： 页面布局重新设计 动态天气的绘制 多城市切换以及管理 新的每日天气趋势图 新的空气质量指示图 一、遇到的问题及踩过的坑 1. 动态天气用自定义 View 、SurfaceView 还是 TextureView ？ 在纠结这个问题之前，我们先简单的对比下它们： View ：Android 基础类，内置画布，提供图形绘制、触屏事件、按键事件等，特点是：必须在 UI 主线程内更新画面。 SurfaceView ：本质上也是一个 View，但它与普通 View 不同的是，它的渲染绘制可以放到其他线程中进行，同时使用双缓冲机制，播放视频时画面更流畅。相对的缺点就是，因为不在 View Hierachy 中，它的显示不受 View 的属性控制，所以不能进行平移、缩放等变换。 TextureView ：官方定义是可以直接将视频流或 OpenGL 场景投影其中；与 SurfaceView 不同的是，TextureView 不会创建一个单独的窗口，而是像普通的 View 那样工作，所以它可以进行平移、缩放等变换。相对的缺点就是，必须在硬件加速的窗口中使用，占用内存比 SurfaceView 高，在 Android 5.0 以前在主线程渲染，5.0 以后有单独的渲染线程。 简单对比后，回到问题本身，我们该如何选择？哪个性能更好？ 这里又不得不提到一个名词：硬件加速：Android 3.0(API 11) 开始，在绘制 View 的时候支持硬件加速，充分利用 GPU 的特性，使得绘制更加平滑，但是会多消耗一些内存。 由于平时并没有深入了解过这一块的知识，网络上搜寻后找到了一些答案： 普通 View 中的 Canvas 是默认开启硬件加速的。 SurfaceView 和 TextureView 里面 lockCanvas() 方法得到的 Canvas 是没有硬件加速的。 Android 6.0(API 23) 之后，android.view.Surface 里新增了 lockHardwareCanvas() 方法来提供硬件加速的 Canvas。 所以说了这么多，一个简单的结论就是：如果需要绘制复杂逻辑场景以及视频流等内容，优选 SurfaceView，如果同时需要有动画效果，选 TextureView；一般的自定义控件以及被动刷新的控件，选择普通 View 可以获得更好的性能表现。 这里我们的动态天气选的是 SurfaceView，当然选择普通 View 或 TextureView也是可以的。更多相关资料可以参考以下链接： SurfaceView TextureView 为什么你的 canvas 那么慢？浅析 Android 的 canvas 性能 视频画面帧的展示控件 SurfaceView 及 TextureView 对比 Android 开源弹幕引擎·烈焰弹幕使 使用多种方式(View/SurfaceView/TextureView)实现高效绘制 2. SurfaceView 在某些设备上会出现 ANR 错误 这个问题最初在一台刷了锤子 OS 的 Nexus 5 上出现，百思不得其解，在 Stack Overflow 上找到了一个相同的提问：ANR in SurfaceView on specific devices only — The only fix is a short sleep time ，虽然没找出问题根源，但是找到了一个奇葩的解决方案： mSurface.unlockCanvasAndPost(canvas); System.out.print(&quot;fuck&quot;); // 是的，没看错，加上这一句就不会报 ANR 错误 3. 天气源引发的思考 App 定位是练手项目，所以数据请求量不是很大，一直使用和风天气，期间有次 key 连续几天超额请求，猜想应该是哪位小伙伴 Fork 项目后直接拿去用了，问题不大，重置下即可。后面把 key 搬到了服务器上，再遇到这种问题就不需要尴尬的重新发布 Apk 了。 重构期间也有考虑过其他天气源，不是收费就是难用。不过为了后期能快速扩展其他天气源，这次还是预留了接口。 和风天气的免费接口，总体来说还算稳定，唯一的缺点就是夜间的时候，逐小时天气没有数据，导致 App 界面下面一截是空白的，貌似这个问题只有更换天气源或者等官方良心发现了，亦或等下次重构了。 二、可能对你有帮助的知识点 如果你有幸看到这篇文章，并给你带来了一点点帮助，那么我会非常开心的。 11 种动态天气效果，平滑渐变切换，还算优雅的动画效果 一个滑动淡入淡出的 ViewPager 指示器 随波逐流的小船儿 一个简单粗暴的闪电生成算法 一个固定子控件高度比例的 LinearLayout 一个新的气温折线图，更加直观 一个新的空气质量 AQI 展示控件,附带动画效果 NestedScrollView 滚动时触发相关子控件动画执行 Fragment 中 public void setUserVisibleHint(boolean isVisibleToUser) 可见&amp;不可见事件只有在 ViewPager 中使用时才会触发 虽然这次重构难度不是很大，但是里面涉及的知识点还是挺有意思的，比如 SurfaceView 的使用、Canvas 的绘制、Path 贝塞尔曲线、属性动画等等，更多细节可以下载 APK 然后直接参考工程代码。 三、写在最后 App 中还有很多细节待完善，一定也存在着诸多 Bug，任何问题和建议可以在项目 Issues 提出，当然也可以发邮件给我。 ","link":"https://liyuyu.cn/post/Refactor-fake-weather/"},{"title":"生命的意义","content":"吃晚饭的时候，媳妇说，她们科室又有一位病人要”冬眠“了，我一阵唏嘘，感慨生命的脆弱，以及在病痛面前的无助，也就这几天，这位病人将通过输麻醉药和镇定剂的方式，缓慢放弃治疗，也就是她们说的“冬眠”。 媳妇在肿瘤科，应该是医院里患者死亡率最高的科室之一了，有的时候，连着几天都会有病人去世，我以为她们目睹过太多的死亡，对于这些早就麻木了，然而每次她跟我说起这些，我都能从她的眼神里读懂对生命的敬畏和惋惜。 有时去医院接媳妇下班，我会在病房里瞎转转，偶尔也会打开他们的 HIS 看看最近收治的新病人，“我记得29床不是个小伙子吗，怎么是老太婆了？！“，”他前几天去世了！“。看着墙上密密麻麻的患者卡片，还有远处过道里，裹着被子睡在长椅上的患者家属，我仿佛听到了“滴答滴答”时间流逝的声音。 每个人对于生命意义的理解是不一样的，与此同时，每个人都在生活，就是在履行生命的意义，生命如艺术品一样，不论其长短，都在生命的过程中彰显着属于他的奇妙意义。这段生命也许只是为了一段旅程，也许只是为了一段风景，也许只是为了一段爱情，这正是生命的美好之处。“死亡权利”将使我们存在的这个世界处处充满生机、美和喜悦。 有一次我和媳妇说：“你在医院工作，我又从事医疗信息行业，原来我们都在为医疗事业贡献自己的力量，为生命保驾护航啊！”，媳妇笑了，我也笑了，这可能就是我们这一生的缘分吧。 ","link":"https://liyuyu.cn/post/The-meaning-of-life/"},{"title":"我的 2016","content":" 下雨的圣诞节，一个人在宿舍宅了两天。天已经黑透了，习惯性的打开手机，纠结着是点外卖还是出去吃。我猛地意识到，2016 年就要过去了。 离职 时间留给我们的除了回忆还有那些写在脸上的沧桑。 年初，由于一些客观的原因，我离职了，待了一年都不到，走得很果断。我一直认为，如果干得不开心，要么忍，要么滚！成天的抱怨，跟临死的哀嚎有什么区别。但我一直对这家公司心存感激，我感激他在 2015 年给了我一次机会，现在回想 2015 年初回苏州的情景，刚买完房，背了一身债，面试的屡屡碰壁，那会儿的人生黑暗到了极点。临走的前一天晚上，我请部门经理和同事吃了饭，酒过三巡，菜过五味，大家各自道别，虽有不舍，但还是停不下来。 新公司 在离开上面那家公司的时候，已经收到 offer 了。年初决定离职的时候，我反反复复的想了好久，迈开这一步，就回不了头了。可能由于自己过去一年的努力和积累，面试的结果是欣慰的，面试了四家，都收到了 offer，经过谨慎的选择，我到了独墅湖这边。 新公司，什么都是新的，我又一次体会到了换工作带来的适应成本。来这边好几个星期了，项目少的可怜，莫名其妙的我有点发慌，没事做的我竟然有点忐忑。一天下午，毫无征兆的我，被“挖”到了另外一个项目组，没有一丝意外，我同意了。谁知道，危机四伏的新项目组，我仅仅干了两个星期就“被离职”了，Android 小组被一锅端。由于还在试用期，所以得不到任何离职赔偿。叒特么要出来找工作了，那一刻我是绝望的。 好在天无绝人之路，后面找工作虽有波折，但结果还算满意，经历了这些，面对 offer 的选择，我又对了一些思考：苏州的互联网氛围其实并不好，有多少公司能静下心来做产品和技术呢，没了业务，我们这些开发人员就是公司里的炮灰了。 一晃来这边大半年了，没啥开心的，也没啥烦心的，平平淡淡，也许这就是工作吧，这一次能走多远？ 生活 说了那么多工作上的事，突然发现生活上没什么可说的了，好像工作成了我们生活的全部。 开心的是，2016，买了人生第一辆车。 ","link":"https://liyuyu.cn/post/My2016/"},{"title":"Android Studio Live Templates","content":"本文翻译自 Writing More Code by Writing Less Code with Android Studio Live Templates 我们都写过大量的 Android 代码，至少也犯过一个如下的错误： Toast.makeText(MainActivity.this, &quot;This will not be displayed&quot;); 其实有一种方法可以避免这个错误，并且不用敲击那么多按键？ 动态模板 如果是有经验的 IntelliJ 用户，可能已经了解过动态模板，而 Android Studio 中也包含了针对 Android 特性的相关模板。 除非你的报酬是特么按敲击次数来计算的，否则估计没有人愿意天天写这些重复的代码。下面这幅图很直观的展示了动态模板是如何工作的： 正如所看到的,动态模板出现在补全选项中,选中动态模板的标签后,插入一个代码片段。 如上所示,输入“Toast”,然后按Tab键后自动生成了一个标准的 Toast，我们还可以通过预设的占位符输来入一些参数。 Android Studio 动态模板 IntelliJ 已经包含了大量的动态模板,而 Android Studio 则为 Android 开发提供了 48 个特有的模板。以下是我最喜欢一些： 动态模板还可以插入一些体量较大的代码片段，比如创建一个 Activity 的静态启动方法： public static void start(android.content.Context context) { android.content.Intent starter = new Intent(context, $ACT$.class); starter.putExtra($CURSOR$); context.startActivity(starter); } 同样，也可以创建一个 Fragment 实例，一个 ViewConstructors，以及一个自定义View的构造方法。 前往File &gt; Settings &gt; Editor &gt; Live Templates 菜单选项查看完整列表。 当然如果你喜欢的模板不存在，你可以创建一个属于你自己的动态模板： 前往 File &gt; Settings &gt; Editor &gt; Live Templates，点击 Android 分组，然后点击 + 号，新增一个动态模板。 其实已经有前辈为我们创建了大量非常有用的动态模板，前往https://github.com/keyboardsurfer/idea-live-templates 尽情享受动态模板带来的便捷吧！ ","link":"https://liyuyu.cn/post/android-studio-live-templates/"}]}